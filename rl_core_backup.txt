RL CORE BACKUP - Thu Feb 26 10:49:44 AM EST 2026
========================================

--- FILE: src/CombatEnv.h ---
#pragma once

#include <Jolt/Jolt.h>
#include <vector>
#include <array>
#include <Jolt/Physics/PhysicsSystem.h>
#include <Jolt/Physics/Collision/ContactListener.h>

#include "PhysicsCore.h"
#include "NeuralMath.h"
#include "NeuralNetwork.h"
#include "CombatRobot.h"
#include "AlignedAllocator.h"

constexpr float ARENA_SIZE = 12.0f;
constexpr float ARENA_HALF = ARENA_SIZE * 0.5f;
constexpr float ROBOT_SPAWN_OFFSET = 3.0f;
constexpr float INITIAL_HP = 100.0f;
constexpr float DAMAGE_MULTIPLIER = 5.0f;
constexpr int MAX_EPISODE_STEPS = 120000;

constexpr int FORCE_SENSOR_DIM = NUM_SATELLITES * 2;
constexpr int OBSERVATION_BASE_DIM = 18 + (NUM_SATELLITES * 6) + (NUM_SATELLITES * 3) + (NUM_SATELLITES * 3);

struct StepResult
{
    static constexpr int OBS_DIM = OBSERVATION_DIM;

    AlignedVector32<float> obs_robot1;
    AlignedVector32<float> obs_robot2;
    VectorReward reward1;
    VectorReward reward2;
    ForceSensorReading forces1;
    ForceSensorReading forces2;
    bool done = false;
    int winner = 0;

    StepResult() : obs_robot1(OBS_DIM), obs_robot2(OBS_DIM) {}
    StepResult(const StepResult& other) = default;
    StepResult& operator=(const StepResult& other) = default;
};

class CombatContactListener : public JPH::ContactListener
{
public:
    CombatContactListener() = default;

    static CombatContactListener& Get();

    void OnContactAdded(const JPH::Body& body1, const JPH::Body& body2,
                        const JPH::ContactManifold& manifold, JPH::ContactSettings& settings) override;
    void OnContactPersisted(const JPH::Body& body1, const JPH::Body& body2,
                            const JPH::ContactManifold& manifold, JPH::ContactSettings& settings) override;
    void OnContactRemoved(const JPH::SubShapeIDPair& subShapePair) override;

    ForceSensorReading& GetForceReading(uint32_t envIdx, int robotIdx)
    {
        return mForceReadingsPerEnv[envIdx][robotIdx];
    }

    const ForceSensorReading& GetForceReading(uint32_t envIdx, int robotIdx) const
    {
        return mForceReadingsPerEnv[envIdx][robotIdx];
    }

    void ResetForceReadings(uint32_t envIdx)
    {
        mForceReadingsPerEnv[envIdx][0].Reset();
        mForceReadingsPerEnv[envIdx][1].Reset();
    }

    void ExtractImpulseData(const JPH::Body& body1, const JPH::Body& body2,
                            const JPH::ContactManifold& manifold);

private:
    std::array<std::array<ForceSensorReading, 2>, NUM_PARALLEL_ENVS> mForceReadingsPerEnv;
};

class CombatEnv
{
public:
    CombatEnv() = default;
    ~CombatEnv() = default;

    CombatEnv(const CombatEnv&) = delete;
    CombatEnv& operator=(const CombatEnv&) = delete;
    CombatEnv(CombatEnv&&) = default;
    CombatEnv& operator=(CombatEnv&&) = default;

    void Init(uint32_t envIndex, JPH::PhysicsSystem* globalPhysics, CombatRobotLoader* globalLoader);
    void Reset();

    void QueueActions(const float* actions1, const float* actions2);
    StepResult HarvestState();

    const CombatRobotData& GetRobot1() const { return mRobot1; }
    const CombatRobotData& GetRobot2() const { return mRobot2; }
    int GetStepCount() const { return mStepCount; }
    bool IsDone() const { return mDone; }
    int GetObservationDim() const { return mObservationDim; }

private:
    void CheckCollisions();
    void CalculateRewards(StepResult& result);
    float ComputeAirtime() const;
    float ComputeEnergyUsed(const float* actions, int actionDim) const;
    void UpdateForceSensors();
    void BuildObservationVector(AlignedVector32<float>& obs, const CombatRobotData& robot,
                                 const CombatRobotData& opponent, const ForceSensorReading& forces);

    JPH::PhysicsSystem* mPhysicsSystem = nullptr;
    CombatRobotLoader* mRobotLoader = nullptr;

    CombatRobotData mRobot1;
    CombatRobotData mRobot2;
    uint32_t mEnvIndex = 0;
    int mStepCount = 0;
    bool mDone = false;
    int mObservationDim = OBSERVATION_DIM;

    float mPrevHp1 = INITIAL_HP;
    float mPrevHp2 = INITIAL_HP;
    float mPrevEnergy1 = 0.0f;
    float mPrevEnergy2 = 0.0f;

    float mAirAccumulator1 = 0.0f;
    float mAirAccumulator2 = 0.0f;
};

--------------------------

--- FILE: src/CombatEnv.cpp ---
#include <Jolt/Jolt.h>
#include "CombatEnv.h"

#include <cmath>
#include <iostream>
#include <Jolt/Physics/Body/BodyInterface.h>
#include <Jolt/Physics/Body/BodyCreationSettings.h>
#include <Jolt/Physics/Collision/Shape/BoxShape.h>

void CombatContactListener::OnContactAdded(const JPH::Body& body1, const JPH::Body& body2,
                                            const JPH::ContactManifold& manifold, JPH::ContactSettings& settings)
{
    ExtractImpulseData(body1, body2, manifold);
}

void CombatContactListener::OnContactPersisted(const JPH::Body& body1, const JPH::Body& body2,
                                                const JPH::ContactManifold& manifold, JPH::ContactSettings& settings)
{
    ExtractImpulseData(body1, body2, manifold);
}

void CombatContactListener::OnContactRemoved(const JPH::SubShapeIDPair& subShapePair)
{
}

void CombatContactListener::ExtractImpulseData(const JPH::Body& body1, const JPH::Body& body2,
                                                const JPH::ContactManifold& manifold)
{
    JPH::ObjectLayer layer1 = body1.GetObjectLayer();
    JPH::ObjectLayer layer2 = body2.GetObjectLayer();

    uint32_t envIdx1 = (layer1 == Layers::STATIC) ? static_cast<uint32_t>(-1) : (layer1 - Layers::MOVING_BASE);
    uint32_t envIdx2 = (layer2 == Layers::STATIC) ? static_cast<uint32_t>(-1) : (layer2 - Layers::MOVING_BASE);

    uint32_t envIdx;
    if (layer1 == Layers::STATIC && layer2 != Layers::STATIC) {
        envIdx = envIdx2;
    } else if (layer2 == Layers::STATIC && layer1 != Layers::STATIC) {
        envIdx = envIdx1;
    } else if (layer1 != Layers::STATIC && layer2 != Layers::STATIC) {
        if (envIdx1 != envIdx2) return;
        envIdx = envIdx1;
    } else {
        return; // Static-static collisions are ignored
    }

    if (envIdx >= NUM_PARALLEL_ENVS) return;

    float impulseMag = manifold.mPenetrationDepth * manifold.mWorldSpaceNormal.Length();
    
    mForceReadingsPerEnv[envIdx][0].impulseMagnitude[0] += impulseMag;
    mForceReadingsPerEnv[envIdx][1].impulseMagnitude[0] += impulseMag;
}

void CombatEnv::Init(uint32_t envIndex, JPH::PhysicsSystem* globalPhysics, CombatRobotLoader* globalLoader)
{
    mEnvIndex = envIndex;
    mPhysicsSystem = globalPhysics;
    mRobotLoader = globalLoader;

    // Fixed spawn: robots at (-2, 2.5, 0) and (2, 2.5, 0) in the single room
    JPH::RVec3 pos1(-2.0f, 2.5f, 0.0f);
    JPH::RVec3 pos2(2.0f, 2.5f, 0.0f);

    std::cout << " [LoadRobot1] " << std::flush;
    mRobot1 = mRobotLoader->LoadRobot("robots/combat_bot.json", mPhysicsSystem, pos1, mEnvIndex, 0);
    std::cout << " [LoadRobot2] " << std::flush;
    mRobot2 = mRobotLoader->LoadRobot("robots/combat_bot.json", mPhysicsSystem, pos2, mEnvIndex, 1);

    mStepCount = 0;
    mDone = false;
    mPrevHp1 = INITIAL_HP;
    mPrevHp2 = INITIAL_HP;
    mPrevEnergy1 = 0.0f;
    mPrevEnergy2 = 0.0f;
    mAirAccumulator1 = 0.0f;
    mAirAccumulator2 = 0.0f;

    CombatContactListener::Get().ResetForceReadings(mEnvIndex);
}

void CombatEnv::Reset()
{
    mStepCount = 0;
    mDone = false;
    mPrevHp1 = INITIAL_HP;
    mPrevHp2 = INITIAL_HP;
    mPrevEnergy1 = 0.0f;
    mPrevEnergy2 = 0.0f;
    mAirAccumulator1 = 0.0f;
    mAirAccumulator2 = 0.0f;

    CombatContactListener::Get().ResetForceReadings(mEnvIndex);

    // Same fixed spawn positions
    JPH::RVec3 pos1(-2.0f, 2.5f, 0.0f);
    JPH::RVec3 pos2(2.0f, 2.5f, 0.0f);

    mRobotLoader->ResetRobot(mRobot1, mPhysicsSystem, pos1);
    mRobotLoader->ResetRobot(mRobot2, mPhysicsSystem, pos2);
}

void CombatEnv::QueueActions(const float* actions1, const float* actions2)
{
    if (mDone) return;
    mRobotLoader->ApplyActions(mRobot1, actions1, mPhysicsSystem);
    mRobotLoader->ApplyActions(mRobot2, actions2, mPhysicsSystem);
}

StepResult CombatEnv::HarvestState()
{
    StepResult result;

    if (mDone) return result;

    mStepCount++;
    CheckCollisions();
    UpdateForceSensors();

    CombatContactListener& listener = CombatContactListener::Get();
    const ForceSensorReading& forces1 = listener.GetForceReading(mEnvIndex, 0);
    const ForceSensorReading& forces2 = listener.GetForceReading(mEnvIndex, 1);

    BuildObservationVector(result.obs_robot1, mRobot1, mRobot2, forces1);
    BuildObservationVector(result.obs_robot2, mRobot2, mRobot1, forces2);

    CalculateRewards(result);

    if (mRobot1.hp <= 0.0f || mRobot2.hp <= 0.0f)
    {
        mDone = true;
        result.done = true;

        if (mRobot1.hp <= 0.0f && mRobot2.hp <= 0.0f)
        {
            result.winner = 0;
        }
        else if (mRobot2.hp <= 0.0f)
        {
            result.winner = 1;
            result.reward1.damage_dealt += 10.0f;
            result.reward2.damage_taken += 10.0f;
        }
        else
        {
            result.winner = 2;
            result.reward2.damage_dealt += 10.0f;
            result.reward1.damage_taken += 10.0f;
        }
    }

    if (mStepCount >= MAX_EPISODE_STEPS)
    {
        mDone = true;
        result.done = true;
        result.reward1.energy_used += 1.0f;
        result.reward2.energy_used += 1.0f;
    }

    mPrevHp1 = mRobot1.hp;
    mPrevHp2 = mRobot2.hp;
    mPrevEnergy1 = mRobot1.totalEnergyUsed;
    mPrevEnergy2 = mRobot2.totalEnergyUsed;

    return result;
}

void CombatEnv::CheckCollisions()
{
    JPH::BodyInterface& bodyInterface = mPhysicsSystem->GetBodyInterface();
    const float collisionThreshold = 0.55f;

    JPH::RVec3 r2Pos = bodyInterface.GetPosition(mRobot2.mainBodyId);
    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        JPH::RVec3 spikePos = bodyInterface.GetPosition(mRobot1.satellites[i].spikeBodyId);
        float dist = static_cast<float>((spikePos - r2Pos).Length());

        if (dist < collisionThreshold)
        {
            JPH::Vec3 spikeVel = bodyInterface.GetLinearVelocity(mRobot1.satellites[i].spikeBodyId);
            float damage = spikeVel.Length() * DAMAGE_MULTIPLIER * 0.001f;
            mRobot2.hp -= damage;
            mRobot1.totalDamageDealt += damage;
            mRobot2.totalDamageTaken += damage;
        }
    }

    JPH::RVec3 r1Pos = bodyInterface.GetPosition(mRobot1.mainBodyId);
    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        JPH::RVec3 spikePos = bodyInterface.GetPosition(mRobot2.satellites[i].spikeBodyId);
        float dist = static_cast<float>((spikePos - r1Pos).Length());

        if (dist < collisionThreshold)
        {
            JPH::Vec3 spikeVel = bodyInterface.GetLinearVelocity(mRobot2.satellites[i].spikeBodyId);
            float damage = spikeVel.Length() * DAMAGE_MULTIPLIER * 0.001f;
            mRobot1.hp -= damage;
            mRobot2.totalDamageDealt += damage;
            mRobot1.totalDamageTaken += damage;
        }
    }
}

void CombatEnv::UpdateForceSensors()
{
    CombatContactListener& listener = CombatContactListener::Get();
    
    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        // Update joint stress for robot 1
        if (mRobot1.satellites[i].rotationJoint != nullptr)
        {
            JPH::Vec3 lagrange = mRobot1.satellites[i].rotationJoint->GetTotalLambdaPosition();
            listener.GetForceReading(mEnvIndex, 0).jointStress[i] = lagrange.Length() * 0.001f;
        }
        
        // Update joint stress for robot 2
        if (mRobot2.satellites[i].rotationJoint != nullptr)
        {
            JPH::Vec3 lagrange = mRobot2.satellites[i].rotationJoint->GetTotalLambdaPosition();
            listener.GetForceReading(mEnvIndex, 1).jointStress[i] = lagrange.Length() * 0.001f;
        }
    }
}

void CombatEnv::BuildObservationVector(AlignedVector32<float>& obs, const CombatRobotData& robot,
                                        const CombatRobotData& opponent, const ForceSensorReading& forces)
{
    JPH::BodyInterface& bodyInterface = mPhysicsSystem->GetBodyInterface();
    int idx = 0;

    JPH::RVec3 myPos = bodyInterface.GetPosition(robot.mainBodyId);
    JPH::Vec3 myVel = bodyInterface.GetLinearVelocity(robot.mainBodyId);
    JPH::Vec3 myAngVel = bodyInterface.GetAngularVelocity(robot.mainBodyId);
    JPH::Quat myRot = bodyInterface.GetRotation(robot.mainBodyId);

    obs[idx++] = static_cast<float>(myPos.GetX());
    obs[idx++] = static_cast<float>(myPos.GetY());
    obs[idx++] = static_cast<float>(myPos.GetZ());
    obs[idx++] = myVel.GetX();
    obs[idx++] = myVel.GetY();
    obs[idx++] = myVel.GetZ();
    obs[idx++] = myAngVel.GetX();
    obs[idx++] = myAngVel.GetY();
    obs[idx++] = myAngVel.GetZ();

    JPH::RVec3 oppPos = bodyInterface.GetPosition(opponent.mainBodyId);
    JPH::Vec3 oppVel = bodyInterface.GetLinearVelocity(opponent.mainBodyId);
    JPH::RVec3 relPos = oppPos - myPos;

    obs[idx++] = static_cast<float>(relPos.GetX());
    obs[idx++] = static_cast<float>(relPos.GetY());
    obs[idx++] = static_cast<float>(relPos.GetZ());
    obs[idx++] = oppVel.GetX();
    obs[idx++] = oppVel.GetY();
    obs[idx++] = oppVel.GetZ();

    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        JPH::RVec3 pos = bodyInterface.GetPosition(robot.satellites[i].coreBodyId);
        JPH::Vec3 vel = bodyInterface.GetLinearVelocity(robot.satellites[i].coreBodyId);
        obs[idx++] = static_cast<float>(pos.GetX());
        obs[idx++] = static_cast<float>(pos.GetY());
        obs[idx++] = static_cast<float>(pos.GetZ());
        obs[idx++] = vel.GetX();
        obs[idx++] = vel.GetY();
        obs[idx++] = vel.GetZ();
    }

    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        JPH::RVec3 pos = bodyInterface.GetPosition(robot.satellites[i].spikeBodyId);
        obs[idx++] = static_cast<float>(pos.GetX());
        obs[idx++] = static_cast<float>(pos.GetY());
        obs[idx++] = static_cast<float>(pos.GetZ());
    }

    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        JPH::RVec3 pos = bodyInterface.GetPosition(opponent.satellites[i].spikeBodyId);
        obs[idx++] = static_cast<float>(pos.GetX());
        obs[idx++] = static_cast<float>(pos.GetY());
        obs[idx++] = static_cast<float>(pos.GetZ());
    }

    obs[idx++] = robot.hp / 100.0f;
    obs[idx++] = opponent.hp / 100.0f;
    obs[idx++] = static_cast<float>((oppPos - myPos).Length()) / 20.0f;
    
    JPH::Vec3 myForward = myRot.RotateAxisY();
    JPH::Vec3 toOpponent = (oppPos - myPos).Normalized();
    float facingDot = myForward.Dot(toOpponent);
    obs[idx++] = facingDot;
    
    float healthDiff = (robot.hp - opponent.hp) / 100.0f;
    obs[idx++] = healthDiff;
    
    float mySpeed = myVel.Length();
    float oppSpeed = oppVel.Length();
    obs[idx++] = mySpeed / 10.0f;
    obs[idx++] = oppSpeed / 10.0f;

    float speedRatio = (oppSpeed > 0.01f) ? (mySpeed / oppSpeed) : 1.0f;
    obs[idx++] = std::clamp(speedRatio, 0.0f, 5.0f) / 5.0f;

    JPH::Vec3 relVel = oppVel - myVel;
    obs[idx++] = relVel.GetX() / 10.0f;
    obs[idx++] = relVel.GetY() / 10.0f;
    obs[idx++] = relVel.GetZ() / 10.0f;

    float closingSpeed = -relVel.Dot(toOpponent);
    obs[idx++] = closingSpeed / 10.0f;

    JPH::Vec3 crossProduct = myVel.Cross(oppVel);
    obs[idx++] = crossProduct.GetX() / 10.0f;
    obs[idx++] = crossProduct.GetY() / 10.0f;

    obs[idx++] = robot.totalDamageDealt / 100.0f;
    obs[idx++] = robot.totalDamageTaken / 100.0f;
    obs[idx++] = robot.episodeSteps / 1000.0f;
    
    // Force sensors (26 dims)
    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        obs[idx++] = forces.impulseMagnitude[i];
    }
    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        obs[idx++] = forces.jointStress[i];
    }
    
    // Altimeter (13 dims)
    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        JPH::RVec3 satPos = bodyInterface.GetPosition(robot.satellites[i].coreBodyId);
        obs[idx++] = static_cast<float>(satPos.GetY()) / 10.0f;
    }
    
    // Local Gravity (3 dims)
    JPH::Vec3 worldGravity(0.0f, -1.0f, 0.0f);
    JPH::Vec3 localGravity = myRot.Conjugated() * worldGravity;
    obs[idx++] = localGravity.GetX();
    obs[idx++] = localGravity.GetY();
    obs[idx++] = localGravity.GetZ();
    
    // Angular Momentum (3 dims)
    constexpr float coreMass = 13.0f;
    obs[idx++] = myAngVel.GetX() * coreMass;
    obs[idx++] = myAngVel.GetY() * coreMass;
    obs[idx++] = myAngVel.GetZ() * coreMass;
    
    // Arena Center Dist (2 dims)
    obs[idx++] = static_cast<float>(myPos.GetX()) / 100.0f;
    obs[idx++] = static_cast<float>(myPos.GetZ()) / 100.0f;
    
    // Time-to-Collision (1 dim)
    float dist = static_cast<float>((oppPos - myPos).Length());
    float closing_speed = -relVel.Dot(toOpponent);
    float timeToCollision = dist / std::max(std::abs(closing_speed), 0.1f);
    obs[idx++] = timeToCollision / 20.0f;

    // Padding for AVX2 alignment (4 elements)
    obs[idx++] = 0.0f;
    obs[idx++] = 0.0f;
    obs[idx++] = 0.0f;
    obs[idx++] = 0.0f;

    // Verify dimension
    if (idx != 240) {
        std::cerr << "[FATAL] BuildObservationVector wrote " << idx << " elements, expected 240!" << std::endl;
        throw std::runtime_error("Observation dimension mismatch");
    }
}

float CombatEnv::ComputeAirtime() const
{
    JPH::BodyInterface& bodyInterface = mPhysicsSystem->GetBodyInterface();
    
    float airtime = 0.0f;
    JPH::RVec3 pos1 = bodyInterface.GetPosition(mRobot1.mainBodyId);
    if (pos1.GetY() > 1.0f) airtime += 0.01f;
    
    JPH::RVec3 pos2 = bodyInterface.GetPosition(mRobot2.mainBodyId);
    if (pos2.GetY() > 1.0f) airtime += 0.01f;
    
    return airtime;
}

float CombatEnv::ComputeEnergyUsed(const float* actions, int actionDim) const
{
    float energy = 0.0f;
    for (int i = 0; i < actionDim; ++i)
    {
        energy += std::abs(actions[i]) * 0.001f;
    }
    return -energy;
}

void CombatEnv::CalculateRewards(StepResult& result)
{
    float dmgDealt1 = mRobot1.totalDamageDealt;
    float dmgDealt2 = mRobot2.totalDamageDealt;
    float dmgTaken1 = mRobot1.totalDamageTaken;
    float dmgTaken2 = mRobot2.totalDamageTaken;

    result.reward1.damage_dealt = dmgDealt1 * 0.1f;
    result.reward1.damage_taken = -dmgTaken1 * 0.05f;
    result.reward1.airtime = ComputeAirtime() * 0.01f;
    result.reward1.energy_used = -mRobot1.totalEnergyUsed * 0.001f;

    result.reward2.damage_dealt = dmgDealt2 * 0.1f;
    result.reward2.damage_taken = -dmgTaken2 * 0.05f;
    result.reward2.airtime = ComputeAirtime() * 0.01f;
    result.reward2.energy_used = -mRobot2.totalEnergyUsed * 0.001f;

    JPH::BodyInterface& bodyInterface = mPhysicsSystem->GetBodyInterface();
    JPH::RVec3 pos1 = bodyInterface.GetPosition(mRobot1.mainBodyId);
    JPH::RVec3 pos2 = bodyInterface.GetPosition(mRobot2.mainBodyId);
    float dist = static_cast<float>((pos2 - pos1).Length());

    float proximityReward = -0.001f * (dist - 3.0f);
    result.reward1.damage_dealt += proximityReward;
    result.reward2.damage_dealt += proximityReward;
}

// Define static accessor for global CombatContactListener
CombatContactListener& CombatContactListener::Get()
{
    static CombatContactListener instance;
    return instance;
}

--------------------------

--- FILE: src/VectorizedEnv.h ---
#pragma once

#include <Jolt/Jolt.h>
#include <vector>
#include "CombatEnv.h"
#include "PhysicsCore.h"
#include "AlignedAllocator.h"

class VectorizedEnv
{
public:
    VectorizedEnv(int numEnvs);
    ~VectorizedEnv();
    VectorizedEnv(const VectorizedEnv& other) = default;
    VectorizedEnv& operator=(const VectorizedEnv& other) = default;

    void Init();

    void Step(const AlignedVector32<float>& actions);
    void Reset(int envIndex = -1);
    void ResetDoneEnvs();

    const AlignedVector32<float>& GetObservations() const { return mAllObservations; }
    const AlignedVector32<float>& GetRewards() const { return mAllRewards; }
    const std::vector<bool>& GetDones() const { return mAllDones; }

    CombatEnv& GetEnv(int index) { return mEnvs[index]; }
    int GetNumEnvs() const { return mNumEnvs; }
    int GetObservationDim() const { return mObservationDim; }
    int GetActionDim() const { return mActionDim; }

    JPH::PhysicsSystem* GetGlobalPhysics() { return &mPhysicsCore.GetPhysicsSystem(); }

private:
    PhysicsCore mPhysicsCore;
    CombatRobotLoader mRobotLoader;
    std::vector<CombatEnv> mEnvs;

    int mNumEnvs;
    int mObservationDim = 240; // 236 active sensors + 4 alignment padding
    int mActionDim = 56;
    
    AlignedVector32<float> mAllObservations;
    AlignedVector32<float> mAllRewards;
    std::vector<bool> mAllDones;
};
--------------------------

--- FILE: src/VectorizedEnv.cpp ---
// MUST BE FIRST
#include <Jolt/Jolt.h>
#include "VectorizedEnv.h"

#include <iostream>
#include <algorithm>
#include <thread>
#include <chrono>
#include <Jolt/Physics/Body/BodyCreationSettings.h>
#include <Jolt/Physics/Collision/Shape/BoxShape.h>

#include <Jolt/Physics/Collision/Shape/Shape.h>
#include <Jolt/Physics/PhysicsSystem.h>

// Global single instance of CombatContactListener
CombatContactListener* gCombatContactListener = nullptr;

VectorizedEnv::VectorizedEnv(int numEnvs)
    : mNumEnvs(numEnvs)
{
}

void VectorizedEnv::Init()
{
    if (!mPhysicsCore.Init(mNumEnvs))
    {
        std::cerr << "[JOLTrl] FATAL: Global PhysicsCore failed to initialize!" << std::endl;
        return;
    }

    // Create and register the global CombatContactListener
    gCombatContactListener = &CombatContactListener::Get();
    mPhysicsCore.GetPhysicsSystem().SetContactListener(gCombatContactListener);

    // --- BUILD EXACTLY ONE 12x12x12 CUBE ROOM AT ORIGIN ---
    JPH::BodyInterface& body_interface = mPhysicsCore.GetPhysicsSystem().GetBodyInterface();
    
    // Floor: 12x12 meters, 0.5m thick, at y=0 (bottom surface y=0, top surface y=0.5)
    JPH::BoxShapeSettings floor_shape(JPH::Vec3(6.0f, 0.25f, 6.0f));
    JPH::RefConst<JPH::Shape> floor = floor_shape.Create().Get();
    JPH::BodyCreationSettings floor_settings(floor, JPH::RVec3(0.0f, 0.25f, 0.0f), JPH::Quat::sIdentity(), JPH::EMotionType::Static, Layers::STATIC);
    body_interface.CreateAndAddBody(floor_settings, JPH::EActivation::DontActivate);
    
    // Ceiling: at y=12, bottom surface y=12
    JPH::BodyCreationSettings ceil_settings(floor, JPH::RVec3(0.0f, 12.0f, 0.0f), JPH::Quat::sIdentity(), JPH::EMotionType::Static, Layers::STATIC);
    body_interface.CreateAndAddBody(ceil_settings, JPH::EActivation::DontActivate);
    
    // Walls: 12m tall (y=0 to y=12), 0.5m thick, 12m wide
    JPH::BoxShapeSettings wall_x_shape(JPH::Vec3(0.25f, 6.0f, 6.0f)); // Walls on X sides (rotate to align)
    JPH::RefConst<JPH::Shape> wall_x = wall_x_shape.Create().Get();
    
    JPH::BoxShapeSettings wall_z_shape(JPH::Vec3(6.0f, 6.0f, 0.25f)); // Walls on Z sides
    JPH::RefConst<JPH::Shape> wall_z = wall_z_shape.Create().Get();
    
    // North wall (z = -6.0)
    JPH::BodyCreationSettings north_wall(wall_z, JPH::RVec3(0.0f, 6.0f, -6.0f), JPH::Quat::sIdentity(), JPH::EMotionType::Static, Layers::STATIC);
    body_interface.CreateAndAddBody(north_wall, JPH::EActivation::DontActivate);
    
    // South wall (z = +6.0)
    JPH::BodyCreationSettings south_wall(wall_z, JPH::RVec3(0.0f, 6.0f, 6.0f), JPH::Quat::sIdentity(), JPH::EMotionType::Static, Layers::STATIC);
    body_interface.CreateAndAddBody(south_wall, JPH::EActivation::DontActivate);
    
    // East wall (x = +6.0) - rotate 90 degrees around Y
    JPH::BodyCreationSettings east_wall(wall_x, JPH::RVec3(6.0f, 6.0f, 0.0f), JPH::Quat::sRotation(JPH::Vec3::sAxisY(), JPH::DegreesToRadians(90.0f)), JPH::EMotionType::Static, Layers::STATIC);
    body_interface.CreateAndAddBody(east_wall, JPH::EActivation::DontActivate);
    
    // West wall (x = -6.0) - rotate 90 degrees around Y
    JPH::BodyCreationSettings west_wall(wall_x, JPH::RVec3(-6.0f, 6.0f, 0.0f), JPH::Quat::sRotation(JPH::Vec3::sAxisY(), JPH::DegreesToRadians(90.0f)), JPH::EMotionType::Static, Layers::STATIC);
    body_interface.CreateAndAddBody(west_wall, JPH::EActivation::DontActivate);
    // -------------------------------------------------

    mEnvs.resize(mNumEnvs);
    std::cout << "[JOLTrl] Initializing " << mNumEnvs << " environments..." << std::endl;
    for (int i = 0; i < mNumEnvs; ++i)
    {
        std::cout << "[JOLTrl] Init env " << i << "..." << std::flush;
        mEnvs[i].Init(i, &mPhysicsCore.GetPhysicsSystem(), &mRobotLoader);
        std::cout << " done" << std::endl;
    }
    std::cout << "[JOLTrl] All environments initialized." << std::endl;

    mObservationDim = mEnvs[0].GetObservationDim();

    std::cout << "[JOLTrl] Resizing observation and reward arrays..." << std::endl;
    mAllObservations.resize(mNumEnvs * mObservationDim * 2, 0.0f);
    mAllRewards.resize(mNumEnvs * 2, 0.0f);
    mAllDones.resize(mNumEnvs, false);
    
    AssertAligned32(mAllObservations.data());
    AssertAligned32(mAllRewards.data());

    std::cout << "[JOLTrl] Calling Reset(-1)..." << std::endl;
    Reset(-1);
    std::cout << "[JOLTrl] Reset(-1) completed." << std::endl;

    // Call broadphase optimization after a small delay to ensure all bodies are added
    std::this_thread::sleep_for(std::chrono::milliseconds(100));
    mPhysicsCore.GetPhysicsSystem().OptimizeBroadPhase();
    std::cout << "[JOLTrl] Global BroadPhase optimized. Engine ready." << std::endl;
}

void VectorizedEnv::Step(const AlignedVector32<float>& actions)
{
    const int actionDim = ACTIONS_PER_ROBOT;

    for (int i = 0; i < mNumEnvs; ++i)
    {
        if (mAllDones[i]) continue;

        const float* actions1 = actions.data() + (i * 2 * actionDim);
        const float* actions2 = actions1 + actionDim;

        mEnvs[i].QueueActions(actions1, actions2);
    }

    // The Global Matrix Crunch (1/120f guarantees RL stability)
    mPhysicsCore.Step(1.0f / 120.0f);

    for (int i = 0; i < mNumEnvs; ++i)
    {
        if (mAllDones[i]) continue;

        StepResult result = mEnvs[i].HarvestState();
        int obsOffset = i * mObservationDim * 2;
        std::copy(result.obs_robot1.begin(), result.obs_robot1.end(), mAllObservations.begin() + obsOffset);
        std::copy(result.obs_robot2.begin(), result.obs_robot2.end(),
                  mAllObservations.begin() + obsOffset + mObservationDim);

        int rewardOffset = i * 2;
        mAllRewards[rewardOffset] = result.reward1.Scalar();
        mAllRewards[rewardOffset + 1] = result.reward2.Scalar();

        mAllDones[i] = result.done;
    }
}

void VectorizedEnv::Reset(int envIndex)
{
    if (envIndex < 0)
    {
        for (auto& env : mEnvs) env.Reset();
        std::fill(mAllDones.begin(), mAllDones.end(), false);
    }
    else
    {
        mEnvs[envIndex].Reset();
        mAllDones[envIndex] = false;
    }
}

void VectorizedEnv::ResetDoneEnvs()
{
    for (int i = 0; i < mNumEnvs; ++i)
    {
        if (mAllDones[i])
        {
            mEnvs[i].Reset();
            mAllDones[i] = false;
        }
    }
}

VectorizedEnv::~VectorizedEnv()
{
    if (gCombatContactListener)
    {
        mPhysicsCore.GetPhysicsSystem().SetContactListener(nullptr);
        gCombatContactListener = nullptr;
    }
}

--------------------------

--- FILE: src/TD3Trainer.h ---
#pragma once

#include <memory>
#include <random>
#include <vector>
#include <array>
#include <cmath>

#include "SpanNetwork.h"
#include "LatentMemory.h"
#include "OpponentPool.h"
#include "NeuralMath.h"
#include "NeuralNetwork.h"
#include "AlignedAllocator.h"

struct TD3Config
{
    int hiddenDim = 256;
    int latentDim = 64;
    float actorLR = 3e-4f;
    float criticLR = 3e-4f;
    float gamma = 0.99f;
    float tau = 0.005f;
    float policyNoise = 0.2f;
    float noiseClip = 0.5f;
    float explNoise = 0.1f;
    int policyDelay = 2;
    int batchSize = 256;
    int bufferSize = 1000000;
    int startSteps = 10000;
    int snapshotInterval = 10000;
};

class TD3Trainer
{
public:
    TD3Trainer(int stateDim, int actionDim, const TD3Config& config = TD3Config());
    TD3Trainer(const TD3Trainer& other) = default;
    TD3Trainer& operator=(const TD3Trainer& other) = default;
    
    void SelectAction(const float* state, float* action);
    void SelectActionEval(const float* state, float* action);
    void SelectActionWithLatent(const float* state, float* action, int envIdx);
    void SelectActionResidual(const float* state, float* residualAction);
    
    void Train(class ReplayBuffer& buffer);
    void TrainWithVectorRewards(class ReplayBuffer& buffer);
    
    void Save(const std::string& path) const;
    void Load(const std::string& path);
    
    int GetStepCount() const { return mStepCount; }
    void IncrementStep() { mStepCount++; }
    
    SpanActorCritic& GetModel() { return mModel; }
    const SpanActorCritic& GetModel() const { return mModel; }

    void SetPreferenceVector(const std::array<float, VECTOR_REWARD_DIM>& pref) { mPreferenceVector = pref; }
    const std::array<float, VECTOR_REWARD_DIM>& GetPreferenceVector() const { return mPreferenceVector; }
    void SetPreference(float damageDealt, float damageTaken, float airtime, float energy)
    {
        mPreferenceVector[0] = damageDealt;
        mPreferenceVector[1] = damageTaken;
        mPreferenceVector[2] = airtime;
        mPreferenceVector[3] = energy;
    }

    float ComputeScalarReward(const VectorReward& vr) const
    {
        return vr.Dot(mPreferenceVector);
    }

    OpponentPool& GetOpponentPool() { return mOpponentPool; }
    const OpponentPool& GetOpponentPool() const { return mOpponentPool; }
    
    void SnapshotOpponent();
    bool SampleOpponent();

private:
    void UpdateCritic(class ReplayBuffer& buffer);
    void UpdateActor();
    void UpdateTargets();
    void UpdateCriticWithVectorRewards(class ReplayBuffer& buffer);
    
    int mStateDim;
    int mActionDim;
    TD3Config mConfig;
    std::mt19937 mRng;
    
    std::array<float, VECTOR_REWARD_DIM> mPreferenceVector = {0.5f, 0.3f, 0.15f, 0.05f};
    
    SpanActorCritic mModel;
    OpponentPool mOpponentPool;
    
    AlignedVector32<float> mBatchStates;
    AlignedVector32<float> mBatchActions;
    AlignedVector32<float> mBatchRewards;
    AlignedVector32<float> mBatchNextStates;
    AlignedVector32<float> mBatchDones;

    std::vector<VectorReward> mBatchVectorRewards;
    
    AlignedVector32<float> mNextActions;
    AlignedVector32<float> mQ1Values;
    AlignedVector32<float> mQ2Values;
    AlignedVector32<float> mTargetQ;
    
    AlignedVector32<float> mGrads;

    AlignedVector32<float> mBatchLogProbs;
    AlignedVector32<float> mTargetLogProbs;
    std::vector<int> mSampledIndices;

    AlignedVector32<float> mCriticInputBuffer;

    int mStepCount = 0;
    int mUpdateCount = 0;
};

--------------------------

--- FILE: src/TD3Trainer.cpp ---
#include "TD3Trainer.h"

#include <fstream>
#include <iostream>
#include <algorithm>
#include <cmath>
#include "AlignedAllocator.h"

TD3Trainer::TD3Trainer(int stateDim, int actionDim, const TD3Config& config)
    : mStateDim(stateDim)
    , mActionDim(actionDim)
    , mConfig(config)
    , mRng(42)
    , mOpponentPool(MAX_POOL_SIZE)
{
    mModel.Init(stateDim, actionDim, config.hiddenDim, config.latentDim, mRng);
    
    int batchSize = config.batchSize;
    mBatchStates.resize(batchSize * stateDim);
    mBatchActions.resize(batchSize * actionDim);
    mBatchRewards.resize(batchSize);
    mBatchNextStates.resize(batchSize * stateDim);
    mBatchDones.resize(batchSize);
    mBatchVectorRewards.resize(batchSize);
    
    mNextActions.resize(batchSize * actionDim);
    mQ1Values.resize(batchSize * 4);
    mQ2Values.resize(batchSize * 4);
    mTargetQ.resize(batchSize);
    mGrads.resize(mModel.GetActor().GetNumWeights());

    int criticInputDim = stateDim + actionDim + config.latentDim;
    mCriticInputBuffer.resize(criticInputDim);
}

void TD3Trainer::SelectAction(const float* state, float* action)
{
    float logProb;
    mModel.SelectAction(state, action, &logProb, true);
}

void TD3Trainer::SelectActionEval(const float* state, float* action)
{
    float logProb;
    mModel.SelectAction(state, action, &logProb, false);
}

void TD3Trainer::SelectActionWithLatent(const float* state, float* action, int envIdx)
{
    float logProb;
    mModel.SelectAction(state, action, &logProb, true);
}

void TD3Trainer::SelectActionResidual(const float* state, float* residualAction)
{
    SelectAction(state, residualAction);
    for (int i = 0; i < mActionDim; ++i)
    {
        residualAction[i] = std::clamp(residualAction[i], -1.0f, 1.0f);
    }
}

void TD3Trainer::Train(ReplayBuffer& buffer)
{
    if (!buffer.IsReady(mConfig.batchSize))
    {
        return;
    }
    
    buffer.Sample(mConfig.batchSize,
                  mBatchStates.data(),
                  mBatchActions.data(),
                  mBatchRewards.data(),
                  mBatchNextStates.data(),
                  mBatchDones.data(),
                  mRng);
    
    UpdateCritic(buffer);
    
    if (mUpdateCount % mConfig.policyDelay == 0)
    {
        UpdateActor();
        UpdateTargets();
    }
    
    mUpdateCount++;
    mStepCount++;
    
    if (mStepCount % mConfig.snapshotInterval == 0)
    {
        SnapshotOpponent();
    }
}

void TD3Trainer::TrainWithVectorRewards(ReplayBuffer& buffer)
{
    if (!buffer.IsReady(mConfig.batchSize))
    {
        return;
    }
    
    buffer.SampleVectorRewards(mConfig.batchSize,
                               mBatchStates.data(),
                               mBatchActions.data(),
                               mBatchVectorRewards.data(),
                               mBatchNextStates.data(),
                               mBatchDones.data(),
                               mRng);
    
    UpdateCriticWithVectorRewards(buffer);
    
    if (mUpdateCount % mConfig.policyDelay == 0)
    {
        UpdateActor();
        UpdateTargets();
    }
    
    mUpdateCount++;
    mStepCount++;
    
    if (mStepCount % mConfig.snapshotInterval == 0)
    {
        SnapshotOpponent();
    }
}

void TD3Trainer::UpdateCritic(ReplayBuffer& buffer)
{
    std::normal_distribution<float> noiseDist(0.0f, mConfig.policyNoise);
    
    for (int i = 0; i < mConfig.batchSize; ++i)
    {
        float* nextAction = mNextActions.data() + i * mActionDim;
        mModel.GetActorTarget().Forward(mBatchNextStates.data() + i * mStateDim, nextAction);
        
        for (int j = 0; j < mActionDim; ++j)
        {
            float noise = std::clamp(noiseDist(mRng), -mConfig.noiseClip, mConfig.noiseClip);
            nextAction[j] = std::clamp(nextAction[j] + noise, -1.0f, 1.0f);
        }
    }
    
    // Properly evaluate target Q-values with state+action+latent concatenation
    int latentDim = mModel.GetLatentDim();
    for (int i = 0; i < mConfig.batchSize; ++i)
    {
        // Get latent state (zero-initialized for now - proper latent tracking needed)
        AlignedVector32<float> zPos(LATENT_DIM, 0.0f);
        mModel.GetLatentMemory().GetLatentStates(zPos.data(), nullptr, 0);

        // Concatenate: state + action + latent into mCriticInputBuffer
        const float* nextState = mBatchNextStates.data() + i * mStateDim;
        const float* nextAction = mNextActions.data() + i * mActionDim;

        int idx = 0;
        std::copy(nextState, nextState + mStateDim, mCriticInputBuffer.data());
        idx += mStateDim;
        std::copy(nextAction, nextAction + mActionDim, mCriticInputBuffer.data() + idx);
        idx += mActionDim;
        std::copy(zPos.data(), zPos.data() + latentDim, mCriticInputBuffer.data() + idx);

        float q1[4], q2[4];
        mModel.GetCritic1Target().Forward(mCriticInputBuffer.data(), q1);
        mModel.GetCritic2Target().Forward(mCriticInputBuffer.data(), q2);

        float minQ = std::min(q1[0], q2[0]);
        mTargetQ[i] = mBatchRewards[i] + mConfig.gamma * (1.0f - mBatchDones[i]) * minQ;
    }
}

void TD3Trainer::UpdateCriticWithVectorRewards(ReplayBuffer& buffer)
{
    std::normal_distribution<float> noiseDist(0.0f, mConfig.policyNoise);
    
    for (int i = 0; i < mConfig.batchSize; ++i)
    {
        float* nextAction = mNextActions.data() + i * mActionDim;
        mModel.GetActorTarget().Forward(mBatchNextStates.data() + i * mStateDim, nextAction);
        
        ForwardMoLU_AVX2(nextAction, mActionDim);
        
        for (int j = 0; j < mActionDim; ++j)
        {
            float noise = std::clamp(noiseDist(mRng), -mConfig.noiseClip, mConfig.noiseClip);
            nextAction[j] = std::clamp(nextAction[j] + noise, -1.0f, 1.0f);
        }
    }
    
    for (int i = 0; i < mConfig.batchSize; ++i)
    {
        float q1[4], q2[4];
        mModel.ComputeQValues(mBatchNextStates.data() + i * mStateDim,
                              mNextActions.data() + i * mActionDim, q1);
        
        float scalarReward = ComputeScalarReward(mBatchVectorRewards[i]);
        float minQ = std::min(q1[0], q2[0]);
        mTargetQ[i] = scalarReward + mConfig.gamma * (1.0f - mBatchDones[i]) * minQ;
    }
}

void TD3Trainer::UpdateActor()
{
    std::normal_distribution<float> noiseDist(0.0f, mConfig.actorLR * 0.1f);
    auto weights = mModel.GetActor().GetAllWeights();
    
    for (auto& w : weights)
    {
        w -= mConfig.actorLR * noiseDist(mRng);
    }
    
    mModel.GetActor().SetAllWeights(weights);
}

void TD3Trainer::UpdateTargets()
{
    mModel.UpdateTargets(mConfig.tau);
}

void TD3Trainer::SnapshotOpponent()
{
    auto weights = mModel.GetActor().GetAllWeights();
    mOpponentPool.Snapshot(weights, {}, mStepCount);
}

bool TD3Trainer::SampleOpponent()
{
    std::vector<float> weights, biases;
    if (mOpponentPool.SampleOpponentRecent(weights, biases, mRng))
    {
        mModel.GetActor().SetAllWeights(weights);
        return true;
    }
    return false;
}

void TD3Trainer::Save(const std::string& path) const
{
    std::ofstream file(path, std::ios::binary);
    if (!file.is_open())
    {
        std::cerr << "TD3Trainer: Failed to save to " << path << std::endl;
        return;
    }
    
    int version = 2;
    file.write(reinterpret_cast<const char*>(&version), sizeof(int));
    file.write(reinterpret_cast<const char*>(&mStateDim), sizeof(int));
    file.write(reinterpret_cast<const char*>(&mActionDim), sizeof(int));
    file.write(reinterpret_cast<const char*>(&mStepCount), sizeof(int));
    
    auto weights = mModel.GetActor().GetAllWeights();
    int numWeights = static_cast<int>(weights.size());
    file.write(reinterpret_cast<const char*>(&numWeights), sizeof(int));
    file.write(reinterpret_cast<const char*>(weights.data()), numWeights * sizeof(float));
    
    file.write(reinterpret_cast<const char*>(mPreferenceVector.data()), 
               VECTOR_REWARD_DIM * sizeof(float));
    
    file.close();
}

void TD3Trainer::Load(const std::string& path)
{
    std::ifstream file(path, std::ios::binary);
    if (!file.is_open())
    {
        std::cerr << "TD3Trainer: Failed to load from " << path << std::endl;
        return;
    }
    
    int version, stateDim, actionDim;
    file.read(reinterpret_cast<char*>(&version), sizeof(int));
    file.read(reinterpret_cast<char*>(&stateDim), sizeof(int));
    file.read(reinterpret_cast<char*>(&actionDim), sizeof(int));
    file.read(reinterpret_cast<char*>(&mStepCount), sizeof(int));
    
    if (stateDim != mStateDim || actionDim != mActionDim)
    {
        std::cerr << "TD3Trainer: Dimension mismatch in loaded model" << std::endl;
        return;
    }
    
    int numWeights;
    file.read(reinterpret_cast<char*>(&numWeights), sizeof(int));
    
    std::vector<float> weights(numWeights);
    file.read(reinterpret_cast<char*>(weights.data()), numWeights * sizeof(float));
    mModel.GetActor().SetAllWeights(weights);
    
    if (version >= 2)
    {
        file.read(reinterpret_cast<char*>(mPreferenceVector.data()),
                  VECTOR_REWARD_DIM * sizeof(float));
    }
    
    mModel.UpdateTargets(1.0f);
    
    file.close();
}

--------------------------

--- FILE: src/SpanNetwork.h ---
#pragma once

#include <vector>
#include <random>
#include <cstdint>
#include <cmath>

#include "NeuralMath.h"
#include "LatentMemory.h"
#include "AlignedAllocator.h"

struct SpanLayerConfig
{
    size_t inputDim;
    size_t outputDim;
    int numKnots = 8;
    int splineDegree = 3;
};

class alignas(32) TensorProductBSpline
{
public:
    TensorProductBSpline() = default;
    TensorProductBSpline(const TensorProductBSpline& other) = default;
    TensorProductBSpline& operator=(const TensorProductBSpline& other) = default;
    
    void Init(size_t inputDim, size_t outputDim, int numKnots, int splineDegree, std::mt19937& rng);
    
    void Forward(const float* input, float* output);
    void ForwardBatch(const float* input, float* output, int batchSize);
    void ForwardAVX2(const float* input, float* output);
    
    AlignedVector32<float>& GetControlPoints() { return mControlPoints; }
    const AlignedVector32<float>& GetControlPoints() const { return mControlPoints; }
    
    size_t GetInputDim() const { return mInputDim; }
    size_t GetOutputDim() const { return mOutputDim; }
    int GetNumKnots() const { return mNumKnots; }
    size_t GetNumParams() const { return mControlPoints.size(); }

private:
    void ComputeBasisFunctions(float x, float* basis, int& spanIdx);
    void ComputeKnotVector();
    
    size_t mInputDim = 0;
    size_t mOutputDim = 0;
    int mNumKnots = 8;
    int mSplineDegree = 3;
    
    AlignedVector32<float> mKnots;
    AlignedVector32<float> mControlPoints;
    
    AlignedVector32<float> mBasisBuffer;
    AlignedVector32<float> mTempOutput;
};

class alignas(32) SpanNetwork
{
public:
    SpanNetwork() = default;
    SpanNetwork(const SpanNetwork& other) = default;
    SpanNetwork& operator=(const SpanNetwork& other) = default;
    
    void Init(const std::vector<SpanLayerConfig>& layerConfigs, std::mt19937& rng);
    
    void Forward(const float* input, float* output);
    void ForwardBatch(const float* input, float* output, int batchSize);
    void ForwardWithLatent(const float* input, float* output, SecondOrderLatentMemory& latent, int envIdx);
    
    std::vector<float> GetAllWeights() const;
    void SetAllWeights(const std::vector<float>& weights);
    size_t GetNumWeights() const;
    
    TensorProductBSpline& GetLayer(size_t idx) { return mLayers[idx]; }
    const TensorProductBSpline& GetLayer(size_t idx) const { return mLayers[idx]; }
    size_t GetNumLayers() const { return mLayers.size(); }
    
    size_t GetInputDim() const { return mInputDim; }
    size_t GetOutputDim() const { return mOutputDim; }
    
    void SoftUpdate(const SpanNetwork& other, float tau);

private:
    AlignedVector32<TensorProductBSpline> mLayers;
    std::vector<size_t> mLayerInputDims;
    std::vector<size_t> mLayerOutputDims;
    size_t mInputDim = 0;
    size_t mOutputDim = 0;
    
    AlignedVector32<float> mActivationBuffer;
};

class alignas(32) SpanActorCritic
{
public:
    SpanActorCritic() = default;
    SpanActorCritic(const SpanActorCritic& other) = default;
    SpanActorCritic& operator=(const SpanActorCritic& other) = default;
    
    void Init(size_t stateDim, size_t actionDim, size_t hiddenDim, size_t latentDim, std::mt19937& rng);
    
    void SelectAction(const float* state, float* action, float* logProb, bool addNoise = true);
    void SelectActionBatch(const float* states, float* actions, float* logProbs, int batchSize, bool addNoise = true);
    
    void ComputeQValues(const float* state, const float* action, float* qValues);
    void ComputeQValuesBatch(const float* states, const float* actions, float* qValues, int batchSize);
    
    void ComputeQ1(const float* state, const float* action, float* qValue);
    void ComputeQ2(const float* state, const float* action, float* qValue);
    
    SpanNetwork& GetActor() { return mActor; }
    SpanNetwork& GetCritic1() { return mCritic1; }
    SpanNetwork& GetCritic2() { return mCritic2; }
    SpanNetwork& GetActorTarget() { return mActorTarget; }
    SpanNetwork& GetCritic1Target() { return mCritic1Target; }
    SpanNetwork& GetCritic2Target() { return mCritic2Target; }
    
    const SpanNetwork& GetActor() const { return mActor; }
    const SpanNetwork& GetCritic1() const { return mCritic1; }
    const SpanNetwork& GetCritic2() const { return mCritic2; }
    const SpanNetwork& GetActorTarget() const { return mActorTarget; }
    const SpanNetwork& GetCritic1Target() const { return mCritic1Target; }
    const SpanNetwork& GetCritic2Target() const { return mCritic2Target; }
    
    class LatentMemoryManager& GetLatentMemory() { return mLatentMemory; }
    
    void UpdateTargets(float tau);
    
    size_t GetStateDim() const { return mStateDim; }
    size_t GetActionDim() const { return mActionDim; }
    size_t GetLatentDim() const { return mLatentDim; }

private:
    SpanNetwork mActor;
    SpanNetwork mCritic1;
    SpanNetwork mCritic2;
    SpanNetwork mActorTarget;
    SpanNetwork mCritic1Target;
    SpanNetwork mCritic2Target;
    
    class LatentMemoryManager mLatentMemory;
    
    size_t mStateDim = 0;
    size_t mActionDim = 0;
    size_t mHiddenDim = 0;
    size_t mLatentDim = 0;
    
    AlignedVector32<float> mStateActionBuffer;
    AlignedVector32<float> mLatentBuffer;
    AlignedVector32<float> mNoiseBuffer;
};

struct alignas(32) CriticBatchBuffer
{
    static constexpr size_t BATCH_SIZE = 256;
    static constexpr size_t HIDDEN_ALIGNED = CRITIC_HIDDEN_DIM_ALIGNED;
    
    alignas(32) float preActivation[BATCH_SIZE * HIDDEN_ALIGNED];
    alignas(32) float postActivation[BATCH_SIZE * HIDDEN_ALIGNED];
    alignas(32) float gradients[BATCH_SIZE * HIDDEN_ALIGNED];
    
    alignas(32) float weights[HIDDEN_ALIGNED * HIDDEN_ALIGNED];
    alignas(32) float biases[HIDDEN_ALIGNED];
    
    void Clear()
    {
        std::memset(preActivation, 0, sizeof(preActivation));
        std::memset(postActivation, 0, sizeof(postActivation));
        std::memset(gradients, 0, sizeof(gradients));
    }
};

--------------------------

--- FILE: src/SpanNetwork.cpp ---
#include "SpanNetwork.h"

#include <algorithm>
#include <immintrin.h>
#include "AlignedAllocator.h"

void TensorProductBSpline::Init(size_t inputDim, size_t outputDim, int numKnots, int splineDegree, std::mt19937& rng)
{
    mInputDim = inputDim;
    mOutputDim = outputDim;
    mNumKnots = numKnots;
    mSplineDegree = splineDegree;
    
    ComputeKnotVector();
    
    size_t numBasis = static_cast<size_t>(numKnots + splineDegree + 1);
    size_t controlPointsPerOutput = numBasis;
    size_t totalControlPoints = outputDim * controlPointsPerOutput;
    
    mControlPoints.resize(totalControlPoints);
    
    std::normal_distribution<float> dist(0.0f, 0.1f);
    for (auto& cp : mControlPoints)
    {
        cp = dist(rng);
    }
    
    mBasisBuffer.resize(numBasis);
    mTempOutput.resize(outputDim);
}

void TensorProductBSpline::ComputeKnotVector()
{
    int numKnots = mNumKnots + mSplineDegree + 1;
    mKnots.resize(numKnots);
    
    int numInternal = mNumKnots - mSplineDegree - 1;
    float step = 1.0f / static_cast<float>(numInternal + 1);
    
    for (int i = 0; i <= mSplineDegree; ++i)
    {
        mKnots[i] = 0.0f;
    }
    
    for (int i = 0; i < numInternal; ++i)
    {
        mKnots[mSplineDegree + 1 + i] = (i + 1) * step;
    }
    
    for (int i = mKnots.size() - mSplineDegree - 1; i < static_cast<int>(mKnots.size()); ++i)
    {
        mKnots[i] = 1.0f;
    }
}

void TensorProductBSpline::ComputeBasisFunctions(float x, float* basis, int& spanIdx)
{
    x = std::clamp(x, 0.0f, 1.0f);
    
    spanIdx = mSplineDegree;
    for (int i = mSplineDegree; i < static_cast<int>(mKnots.size()) - mSplineDegree - 1; ++i)
    {
        if (x >= mKnots[i] && x < mKnots[i + 1])
        {
            spanIdx = i;
            break;
        }
    }
    if (x >= 1.0f - 1e-6f) spanIdx = static_cast<int>(mKnots.size()) - mSplineDegree - 2;
    
    for (int i = 0; i <= mSplineDegree; ++i)
    {
        basis[i] = 0.0f;
    }
    basis[0] = 1.0f;
    
    for (int j = 1; j <= mSplineDegree; ++j)
    {
        float saved = 0.0f;
        for (int r = j; r >= 0; --r)
        {
            int idx = spanIdx - j + r + 1;
            float knotDiff = mKnots[idx + mSplineDegree - j] - mKnots[idx];
            float temp = 0.0f;
            
            if (std::abs(knotDiff) > 1e-8f)
            {
                temp = basis[r] / knotDiff;
            }
            
            basis[r + 1] = basis[r + 1] + temp * (mKnots[spanIdx + j + 1] - mKnots[idx + mSplineDegree - j] > 1e-8f ? 
                         (mKnots[spanIdx + j + 1] - mKnots[idx]) / mKnots[spanIdx + j + 1] : 0.0f);
            if (r > 0)
            {
                basis[r] = saved + temp * (mKnots[idx] - mKnots[spanIdx] > 1e-8f ? 
                          (mKnots[idx] - mKnots[spanIdx]) / (mKnots[idx] - mKnots[spanIdx]) : 0.0f);
            }
            saved = temp * (mKnots[spanIdx + j + 1] - x);
        }
    }
    
    for (int i = 0; i <= mSplineDegree; ++i)
    {
        basis[i] = std::max(0.0f, basis[i]);
    }
}

void TensorProductBSpline::Forward(const float* input, float* output)
{
    size_t numBasis = static_cast<size_t>(mNumKnots + mSplineDegree + 1);
    
    for (size_t outIdx = 0; outIdx < mOutputDim; ++outIdx)
    {
        float sum = 0.0f;
        
        for (size_t inIdx = 0; inIdx < mInputDim; ++inIdx)
        {
            float x = input[inIdx];
            x = tanhf(x) * 0.5f + 0.5f;
            
            int spanIdx;
            ComputeBasisFunctions(x, mBasisBuffer.data(), spanIdx);
            
            for (int b = 0; b <= mSplineDegree; ++b)
            {
                int basisIdx = spanIdx - mSplineDegree + b;
                if (basisIdx >= 0 && static_cast<size_t>(basisIdx) < numBasis)
                {
                    size_t cpIdx = outIdx * numBasis + static_cast<size_t>(basisIdx);
                    sum += mBasisBuffer[b] * mControlPoints[cpIdx];
                }
            }
        }
        
        output[outIdx] = sum / static_cast<float>(mInputDim);
    }
}

void TensorProductBSpline::ForwardBatch(const float* input, float* output, int batchSize)
{
    for (int b = 0; b < batchSize; ++b)
    {
        Forward(input + b * mInputDim, output + b * mOutputDim);
    }
}

void TensorProductBSpline::ForwardAVX2(const float* input, float* output)
{
    size_t numBasis = static_cast<size_t>(mNumKnots + mSplineDegree + 1);
    
    for (size_t outIdx = 0; outIdx < mOutputDim; ++outIdx)
    {
        __m256 sumVec = _mm256_setzero_ps();
        size_t simdInputDim = mInputDim - (mInputDim % 8);
        
        for (size_t inIdx = 0; inIdx < simdInputDim; inIdx += 8)
        {
            __m256 x = _mm256_loadu_ps(input + inIdx);
            
            alignas(32) float xArr[8];
            _mm256_store_ps(xArr, x);
            alignas(32) float tanhArr[8];
            for (int i = 0; i < 8; ++i)
            {
                tanhArr[i] = tanhf(xArr[i]) * 0.5f + 0.5f;
            }
            
            for (int i = 0; i < 8; ++i)
            {
                float xi = tanhArr[i];
                int spanIdx;
                ComputeBasisFunctions(xi, mBasisBuffer.data(), spanIdx);
                
                for (int b = 0; b <= mSplineDegree; ++b)
                {
                    int basisIdx = spanIdx - mSplineDegree + b;
                    if (basisIdx >= 0 && static_cast<size_t>(basisIdx) < numBasis)
                    {
                        size_t cpIdx = outIdx * numBasis + static_cast<size_t>(basisIdx);
                        sumVec = _mm256_add_ps(sumVec, _mm256_set1_ps(mBasisBuffer[b] * mControlPoints[cpIdx]));
                    }
                }
            }
        }
        
        alignas(32) float sumArr[8];
        _mm256_store_ps(sumArr, sumVec);
        float sum = sumArr[0] + sumArr[1] + sumArr[2] + sumArr[3] + sumArr[4] + sumArr[5] + sumArr[6] + sumArr[7];
        
        for (size_t inIdx = simdInputDim; inIdx < mInputDim; ++inIdx)
        {
            float x = input[inIdx];
            x = tanhf(x) * 0.5f + 0.5f;
            
            int spanIdx;
            ComputeBasisFunctions(x, mBasisBuffer.data(), spanIdx);
            
            for (int b = 0; b <= mSplineDegree; ++b)
            {
                int basisIdx = spanIdx - mSplineDegree + b;
                if (basisIdx >= 0 && static_cast<size_t>(basisIdx) < numBasis)
                {
                    size_t cpIdx = outIdx * numBasis + static_cast<size_t>(basisIdx);
                    sum += mBasisBuffer[b] * mControlPoints[cpIdx];
                }
            }
        }
        
        output[outIdx] = sum / static_cast<float>(mInputDim);
    }
}

void SpanNetwork::Init(const std::vector<SpanLayerConfig>& layerConfigs, std::mt19937& rng)
{
    mLayers.resize(layerConfigs.size());
    mLayerInputDims.resize(layerConfigs.size());
    mLayerOutputDims.resize(layerConfigs.size());
    
    size_t maxDim = 0;
    for (size_t i = 0; i < layerConfigs.size(); ++i)
    {
        mLayerInputDims[i] = layerConfigs[i].inputDim;
        mLayerOutputDims[i] = layerConfigs[i].outputDim;
        mLayers[i].Init(layerConfigs[i].inputDim, layerConfigs[i].outputDim,
                        layerConfigs[i].numKnots, layerConfigs[i].splineDegree, rng);
        
        maxDim = std::max(maxDim, std::max(layerConfigs[i].inputDim, layerConfigs[i].outputDim));
    }
    
    if (!layerConfigs.empty())
    {
        mInputDim = layerConfigs.front().inputDim;
        mOutputDim = layerConfigs.back().outputDim;
    }
    
    mActivationBuffer.resize(maxDim * 2);
}

void SpanNetwork::Forward(const float* input, float* output)
{
    if (mLayers.empty()) return;
    
    const float* currentInput = input;
    float* currentOutput = mActivationBuffer.data();
    
    for (size_t i = 0; i < mLayers.size(); ++i)
    {
        mLayers[i].Forward(currentInput, currentOutput);
        
        if (i < mLayers.size() - 1)
        {
            ForwardMoLU_AVX2(currentOutput, mLayerOutputDims[i]);
        }
        
        float* temp = const_cast<float*>(currentInput);
        currentInput = currentOutput;
        currentOutput = temp;
    }
    
    std::copy(currentOutput, currentOutput + mOutputDim, output);
}

void SpanNetwork::ForwardBatch(const float* input, float* output, int batchSize)
{
    for (int b = 0; b < batchSize; ++b)
    {
        Forward(input + b * mInputDim, output + b * mOutputDim);
    }
}

void SpanNetwork::ForwardWithLatent(const float* input, float* output, SecondOrderLatentMemory& latent, int envIdx)
{
    float* zPos = latent.GetPosition(envIdx);
    float* zVel = latent.GetVelocity(envIdx);
    
    int combinedDim = mInputDim + latent.latentDim;
    alignas(32) AlignedVector32<float> combinedInput(combinedDim);
    
    std::copy(input, input + mInputDim, combinedInput.begin());
    std::copy(zPos, zPos + latent.latentDim, combinedInput.begin() + mInputDim);
    
    Forward(combinedInput.data(), output);
}

std::vector<float> SpanNetwork::GetAllWeights() const
{
    std::vector<float> weights;
    for (const auto& layer : mLayers)
    {
        const auto& cp = layer.GetControlPoints();
        weights.insert(weights.end(), cp.begin(), cp.end());
    }
    return weights;
}

void SpanNetwork::SetAllWeights(const std::vector<float>& weights)
{
    size_t offset = 0;
    for (auto& layer : mLayers)
    {
        auto& cp = layer.GetControlPoints();
        size_t n = cp.size();
        std::copy(weights.begin() + offset, weights.begin() + offset + n, cp.begin());
        offset += n;
    }
}

size_t SpanNetwork::GetNumWeights() const
{
    int total = 0;
    for (const auto& layer : mLayers)
    {
        total += layer.GetNumParams();
    }
    return total;
}

void SpanNetwork::SoftUpdate(const SpanNetwork& other, float tau)
{
    auto myWeights = GetAllWeights();
    auto otherWeights = other.GetAllWeights();
    
    for (size_t i = 0; i < myWeights.size(); ++i)
    {
        myWeights[i] = (1.0f - tau) * myWeights[i] + tau * otherWeights[i];
    }
    
    SetAllWeights(myWeights);
}

void SpanActorCritic::Init(size_t stateDim, size_t actionDim, size_t hiddenDim, size_t latentDim, std::mt19937& rng)
{
    mStateDim = stateDim;
     mActionDim = actionDim;
     mHiddenDim = hiddenDim;
     mLatentDim = latentDim;
     
     size_t actorInputDim = stateDim + latentDim;
    std::vector<SpanLayerConfig> actorConfig = {
        {actorInputDim, hiddenDim, 8, 3},
        {hiddenDim, hiddenDim, 8, 3},
        {hiddenDim, actionDim, 8, 3}
    };
     mActor.Init(actorConfig, rng);
     mActorTarget.Init(actorConfig, rng);
     
     size_t criticInputDim = stateDim + actionDim + latentDim;
    std::vector<SpanLayerConfig> criticConfig = {
        {criticInputDim, hiddenDim, 8, 3},
        {hiddenDim, hiddenDim, 8, 3},
        {hiddenDim, 4, 8, 3}
    };
    mCritic1.Init(criticConfig, rng);
    mCritic2.Init(criticConfig, rng);
    mCritic1Target.Init(criticConfig, rng);
    mCritic2Target.Init(criticConfig, rng);
    
    mLatentMemory.Init(stateDim, latentDim, rng);
    
    mStateActionBuffer.resize(criticInputDim);
    mLatentBuffer.resize(latentDim);
    mNoiseBuffer.resize(actionDim);
}

void SpanActorCritic::SelectAction(const float* state, float* action, float* logProb, bool addNoise)
{
    mLatentMemory.StepLatentDynamics(state, 1);
    
    AlignedVector32<float> zPos(LATENT_DIM);
    AlignedVector32<float> zVel(LATENT_DIM);
    mLatentMemory.GetLatentStates(zPos.data(), zVel.data(), 0);
    
    size_t combinedDim = mStateDim + mLatentDim;
    alignas(32) AlignedVector32<float> combined(combinedDim);
    std::copy(state, state + mStateDim, combined.begin());
    std::copy(zPos.data(), zPos.data() + mLatentDim, combined.begin() + mStateDim);
    
    mActor.Forward(combined.data(), action);
    
    ForwardMoLU_AVX2(action, mActionDim);
    
    if (addNoise)
    {
        std::normal_distribution<float> noiseDist(0.0f, 0.1f);
        std::mt19937 localRng(0);
        
        float noiseSum = 0.0f;
        for (size_t i = 0; i < mActionDim; ++i)
        {
            float noise = noiseDist(localRng);
            action[i] = std::clamp(action[i] + noise, -1.0f, 1.0f);
            noiseSum += noise * noise;
        }
        
        if (logProb)
        {
            *logProb = -0.5f * noiseSum;
        }
    }
    else if (logProb)
    {
        *logProb = 0.0f;
    }
}

void SpanActorCritic::SelectActionBatch(const float* states, float* actions, float* logProbs, int batchSize, bool addNoise)
{
    for (int b = 0; b < batchSize; ++b)
    {
        SelectAction(states + b * mStateDim, actions + b * mActionDim,
                     logProbs ? logProbs + b : nullptr, addNoise);
    }
}

void SpanActorCritic::ComputeQValues(const float* state, const float* action, float* qValues)
{
    AlignedVector32<float> zPos(LATENT_DIM);
    mLatentMemory.GetLatentStates(zPos.data(), nullptr, 0);
    
    size_t idx = 0;
    for (size_t i = 0; i < mStateDim; ++i)
    {
        mStateActionBuffer[idx++] = state[i];
    }
    for (size_t i = 0; i < mActionDim; ++i)
    {
        mStateActionBuffer[idx++] = action[i];
    }
    for (size_t i = 0; i < mLatentDim; ++i)
    {
        mStateActionBuffer[idx++] = zPos[i];
    }
    
    float q1[4], q2[4];
    mCritic1.Forward(mStateActionBuffer.data(), q1);
    mCritic2.Forward(mStateActionBuffer.data(), q2);
    
    qValues[0] = q1[0];
    qValues[1] = q1[1];
    qValues[2] = q1[2];
    qValues[3] = q1[3];
}

void SpanActorCritic::ComputeQValuesBatch(const float* states, const float* actions, float* qValues, int batchSize)
{
    for (int b = 0; b < batchSize; ++b)
    {
        ComputeQValues(states + b * mStateDim, actions + b * mActionDim, qValues + b * 4);
    }
}

void SpanActorCritic::ComputeQ1(const float* state, const float* action, float* qValue)
{
    AlignedVector32<float> zPos(LATENT_DIM);
    mLatentMemory.GetLatentStates(zPos.data(), nullptr, 0);
    
    size_t idx = 0;
    for (size_t i = 0; i < mStateDim; ++i)
    {
        mStateActionBuffer[idx++] = state[i];
    }
    for (size_t i = 0; i < mActionDim; ++i)
    {
        mStateActionBuffer[idx++] = action[i];
    }
    for (size_t i = 0; i < mLatentDim; ++i)
    {
        mStateActionBuffer[idx++] = zPos[i];
    }
    
    float q[4];
    mCritic1.Forward(mStateActionBuffer.data(), q);
    *qValue = q[0];
}

void SpanActorCritic::ComputeQ2(const float* state, const float* action, float* qValue)
{
    AlignedVector32<float> zPos(LATENT_DIM);
    mLatentMemory.GetLatentStates(zPos.data(), nullptr, 0);
    
    size_t idx = 0;
    for (size_t i = 0; i < mStateDim; ++i)
    {
        mStateActionBuffer[idx++] = state[i];
    }
    for (size_t i = 0; i < mActionDim; ++i)
    {
        mStateActionBuffer[idx++] = action[i];
    }
    for (size_t i = 0; i < mLatentDim; ++i)
    {
        mStateActionBuffer[idx++] = zPos[i];
    }
    
    float q[4];
    mCritic2.Forward(mStateActionBuffer.data(), q);
    *qValue = q[0];
}

void SpanActorCritic::UpdateTargets(float tau)
{
    mActorTarget.SoftUpdate(mActor, tau);
    mCritic1Target.SoftUpdate(mCritic1, tau);
    mCritic2Target.SoftUpdate(mCritic2, tau);
}

--------------------------

--- FILE: src/NeuralNetwork.h ---
#pragma once

#include <vector>
#include <random>
#include <cmath>
#include <cstring>
#include <array>
#include <algorithm>
#include <cstdint>

#include "NeuralMath.h"
#include "LatentMemory.h"
#include "AlignedAllocator.h"

using AlignedVector32f = std::vector<float, AlignedAllocator<float, 32>>;

constexpr int VECTOR_REWARD_DIM = 4;

struct VectorReward
{
    float damage_dealt = 0.0f;
    float damage_taken = 0.0f;
    float airtime = 0.0f;
    float energy_used = 0.0f;

    VectorReward() = default;
    VectorReward(const VectorReward& other) = default;
    VectorReward& operator=(const VectorReward& other) = default;

    float Dot(const std::array<float, 4>& preference) const
    {
        return damage_dealt * preference[0] +
               damage_taken * preference[1] +
               airtime * preference[2] +
               energy_used * preference[3];
    }

    float Scalar() const
    {
        return damage_dealt + damage_taken + airtime + energy_used;
    }
};

static inline float Softplus(float x)
{
    if (x > 20.0f) return x;
    return log1pf(expf(x));
}

static inline float MoLU(float x)
{
    return 0.5f * x * (1.0f + tanhf(x));
}

static inline float MoLUDerivative(float x)
{
    float th = tanhf(x);
    float sech2 = 1.0f - th * th;
    return 0.5f * (1.0f + th) + 0.5f * x * sech2;
}

struct ODE2VAENetwork
{
    AlignedVector32f W_encoder;
    AlignedVector32f b_encoder;
    AlignedVector32f W_vel;
    AlignedVector32f b_vel;
    
    int obsDim;
    int latentDim;

    ODE2VAENetwork() = default;
    ODE2VAENetwork(const ODE2VAENetwork& other) = default;
    ODE2VAENetwork& operator=(const ODE2VAENetwork& other) = default;

    void Init(int observationDim, int latentDim, std::mt19937& rng);
    void EncodeObservation(const float* obs, float* z_pos_out, float* z_vel_out);
    void ComputeAcceleration(const float* z_pos, const float* z_vel, const float* obs, float* accel_out);
};

void ForwardMoLU_AVX2(float* data, size_t size);
void ForwardMoLU_Scalar(float* data, size_t size);

class NeuralNetwork {
public:
    NeuralNetwork(const std::vector<int>& layerSizes);
    ~NeuralNetwork() = default;  // Explicitly define default destructor
    NeuralNetwork(const NeuralNetwork& other) = default;  // Explicitly define default copy constructor
    NeuralNetwork& operator=(const NeuralNetwork& other) = default;  // Explicitly define default assignment operator
    
    void Forward(const float* input, float* output);
    void Forward(const float* input, float* output, int batchSize);
    void ForwardMoLU(const float* input, float* output);
    void ForwardMoLU_AVX2_Batch(const float* input, float* output, int batchSize);

    void ForwardODE2VAE(const float* input, float* output, SecondOrderLatentMemory& memory, int envIdx);
    void ForwardODE2VAEVectorized(const float* inputs, float* outputs, int numEnvs);
    
    AlignedVector32f& GetWeights() { return mWeights; }
    AlignedVector32f& GetBiases() { return mBiases; }
    const AlignedVector32f& GetWeights() const { return mWeights; }
    const AlignedVector32f& GetBiases() const { return mBiases; }
    
    void SetWeights(const AlignedVector32f& weights) { mWeights = weights; }
    void SetBiases(const AlignedVector32f& biases) { mBiases = biases; }
    
    void CopyFrom(const NeuralNetwork& other);
    void SoftUpdate(const NeuralNetwork& other, float tau);
    
    int GetNumWeights() const { return static_cast<int>(mWeights.size()); }
    int GetNumBiases() const { return static_cast<int>(mBiases.size()); }
    int GetInputDim() const { return mLayerSizes.front(); }
    int GetOutputDim() const { return mLayerSizes.back(); }
    
    void InitializeWeights(std::mt19937& rng, float scale = 0.1f);
    void InitODE2VAE(int latentDim, std::mt19937& rng);

    ODE2VAENetwork& GetODE2VAE() { return mODE2VAE; }
    const ODE2VAENetwork& GetODE2VAE() const { return mODE2VAE; }

    SecondOrderLatentMemory& GetLatentMemory() { return mLatentMemory; }
    const SecondOrderLatentMemory& GetLatentMemory() const { return mLatentMemory; }
    
    int GetLatentDim() const { return mODE2VAE.latentDim; }
    bool HasODE2VAE() const { return mHasODE2VAE; }
    
private:
    std::vector<int> mLayerSizes;
    AlignedVector32f mWeights;
    AlignedVector32f mBiases;
    AlignedVector32f mActivations;
    
    std::vector<int> mWeightOffsets;
    std::vector<int> mBiasOffsets;
    std::vector<int> mActivationOffsets;

    ODE2VAENetwork mODE2VAE;
    SecondOrderLatentMemory mLatentMemory;
    bool mHasODE2VAE = false;
    
    static float ReLU(float x) { return x > 0.0f ? x : 0.0f; }
    static float Tanh(float x) { return std::tanh(x); }
};

struct KLPERTransition
{
    AlignedVector32f state;
    AlignedVector32f action;
    AlignedVector32f behaviorLogProb;
    VectorReward reward;
    AlignedVector32f nextState;
    bool done;
    float priority;
    float klDivergence;
    int index;

    KLPERTransition() = default;
    KLPERTransition(const KLPERTransition& other) = default;
    KLPERTransition& operator=(const KLPERTransition& other) = default;
};

class KLPERBuffer {
public:
    KLPERBuffer(int capacity, int stateDim, int actionDim);
    KLPERBuffer(const KLPERBuffer& other) = default;
    KLPERBuffer& operator=(const KLPERBuffer& other) = default;
    
    void Add(const float* state, const float* action, float behaviorLogProb,
             const VectorReward& reward, const float* nextState, bool done);
    
    void Sample(int batchSize, float* states, float* actions, float* logProbs,
                VectorReward* rewards, float* nextStates, float* dones,
                std::vector<int>& indices, std::mt19937& rng);
    
    void UpdatePriorities(const std::vector<int>& indices, const float* targetLogProbs,
                          const float* behaviorLogProbs, int batchSize);
    
    void UpdateKLDivergence(int index, float klDiv);
    float ComputeKLDivergence(float behaviorLogProb, float targetLogProb) const;
    
    int Size() const { return mSize; }
    bool IsReady(int batchSize) const { return mSize >= batchSize; }
    
    void SetAlpha(float alpha) { mAlpha = alpha; }
    void SetBeta(float beta) { mBeta = beta; }

private:
    AlignedVector32f mStates;
    AlignedVector32f mActions;
    AlignedVector32f mBehaviorLogProbs;
    std::vector<VectorReward> mRewards;
    AlignedVector32f mNextStates;
    AlignedVector32f mDones;
    AlignedVector32f mPriorities;
    AlignedVector32f mKLDivergences;
    
    int mCapacity;
    int mStateDim;
    int mActionDim;
    int mSize = 0;
    int mIndex = 0;
    float mAlpha = 0.6f;
    float mBeta = 0.4f;
    float mMaxPriority = 1.0f;
    
    AlignedVector32f mSumTree;
    std::vector<int> mMinTree;
    
    void UpdateTree(int idx, float priority);
    float GetPriorityWeight(int idx) const;
};

class ReplayBuffer {
public:
    ReplayBuffer(int capacity, int stateDim, int actionDim);
    ReplayBuffer(const ReplayBuffer& other) = default;
    ReplayBuffer& operator=(const ReplayBuffer& other) = default;
    
    void Add(const float* state, const float* action, const VectorReward& reward,
             const float* nextState, bool done);
    void Add(const float* state, const float* action, float reward,
             const float* nextState, bool done);
    
    void Sample(int batchSize, float* states, float* actions, float* rewards,
                float* nextStates, float* dones, std::mt19937& rng);
    
    void SampleVectorRewards(int batchSize, float* states, float* actions,
                             VectorReward* rewards, float* nextStates, float* dones,
                             std::mt19937& rng);
    
    int Size() const { return mSize; }
    bool IsReady(int batchSize) const { return mSize >= batchSize; }
    
private:
    AlignedVector32f mStates;
    AlignedVector32f mActions;
    AlignedVector32f mRewards;
    AlignedVector32f mNextStates;
    AlignedVector32f mDones;

    std::vector<VectorReward> mVectorRewards;
    
    int mCapacity;
    int mStateDim;
    int mActionDim;
    int mSize = 0;
    int mIndex = 0;
};
--------------------------

--- FILE: src/NeuralNetwork.cpp ---
#include "NeuralNetwork.h"

#include <algorithm>
#include <immintrin.h>
#include <limits>
#include <vector>
#include <cmath>

void ODE2VAENetwork::Init(int observationDim, int latentDim, std::mt19937& rng)
{
    obsDim = observationDim;
    this->latentDim = latentDim;
    
    std::normal_distribution<float> dist(0.0f, 0.1f);
    
    W_encoder.resize(latentDim * 2 * observationDim);
    b_encoder.resize(latentDim * 2);
    W_vel.resize(latentDim * (latentDim * 2 + observationDim));
    b_vel.resize(latentDim);
    
    for (auto& w : W_encoder) w = dist(rng);
    for (auto& w : W_vel) w = dist(rng);
    
    for (int i = 0; i < latentDim * 2; ++i)
    {
        b_encoder[i] = 0.0f;
    }
    for (int i = 0; i < latentDim; ++i)
    {
        b_vel[i] = 0.0f;
    }
}

void ODE2VAENetwork::EncodeObservation(const float* obs, float* z_pos_out, float* z_vel_out)
{
    for (int i = 0; i < latentDim; ++i)
    {
        float pos_val = b_encoder[i];
        float vel_val = b_encoder[latentDim + i];
        
        for (int j = 0; j < obsDim; ++j)
        {
            float o = obs[j];
            pos_val += W_encoder[i * obsDim + j] * o;
            vel_val += W_encoder[(latentDim + i) * obsDim + j] * o;
        }
        
        z_pos_out[i] = tanhf(pos_val);
        z_vel_out[i] = tanhf(vel_val);
    }
}

void ODE2VAENetwork::ComputeAcceleration(const float* z_pos, const float* z_vel, 
                                          const float* obs, float* accel_out)
{
    const int inputDim = latentDim * 2 + obsDim;
    AlignedVector32f combined(inputDim);
    
    for (int i = 0; i < latentDim; ++i)
    {
        combined[i] = z_pos[i];
        combined[latentDim + i] = z_vel[i];
    }
    for (int i = 0; i < obsDim; ++i)
    {
        combined[latentDim * 2 + i] = obs[i];
    }
    
    for (int i = 0; i < latentDim; ++i)
    {
        float val = b_vel[i];
        for (int j = 0; j < inputDim; ++j)
        {
            val += W_vel[i * inputDim + j] * combined[j];
        }
        accel_out[i] = tanhf(val);
    }
}

NeuralNetwork::NeuralNetwork(const std::vector<int>& layerSizes)
    : mLayerSizes(layerSizes)
{
    if (layerSizes.size() < 2) return;
    
    int totalWeights = 0;
    int totalBiases = 0;
    int totalActivations = 0;
    
    for (size_t i = 1; i < layerSizes.size(); ++i) {
        int inSize = layerSizes[i - 1];
        int outSize = layerSizes[i];
        totalWeights += inSize * outSize;
        totalBiases += outSize;
        totalActivations += outSize;
    }
    
    mWeights.resize(totalWeights);
    mBiases.resize(totalBiases);
    mActivations.resize(totalActivations);
    
    int weightOffset = 0;
    int biasOffset = 0;
    int activationOffset = 0;
    
    for (size_t i = 0; i < layerSizes.size(); ++i) {
        mActivationOffsets.push_back(activationOffset);
        activationOffset += layerSizes[i];
    }
    
    for (size_t i = 1; i < layerSizes.size(); ++i) {
        mWeightOffsets.push_back(weightOffset);
        mBiasOffsets.push_back(biasOffset);
        
        weightOffset += layerSizes[i - 1] * layerSizes[i];
        biasOffset += layerSizes[i];
    }
}

void NeuralNetwork::InitializeWeights(std::mt19937& rng, float scale) {
    std::normal_distribution<float> dist(0.0f, scale);
    
    for (auto& w : mWeights) {
        w = dist(rng);
    }
    
    for (auto& b : mBiases) {
        b = 0.0f;
    }
}

void NeuralNetwork::InitODE2VAE(int latentDim, std::mt19937& rng)
{
    mHasODE2VAE = true;
    mODE2VAE.Init(mLayerSizes.front(), latentDim, rng);
    mLatentMemory.Init();
}

void NeuralNetwork::Forward(const float* input, float* output) {
    int inputSize = mLayerSizes[0];
    std::copy(input, input + inputSize, mActivations.begin());
    
    int actOffset = 0;
    int weightIdx = 0;
    int biasIdx = 0;
    
    for (size_t layer = 1; layer < mLayerSizes.size(); ++layer) {
        int inSize = mLayerSizes[layer - 1];
        int outSize = mLayerSizes[layer];
        
        const float* in = mActivations.data() + actOffset;
        float* out = mActivations.data() + actOffset + inSize;
        
        for (int j = 0; j < outSize; ++j) {
            float sum = mBiases[biasIdx + j];
            
            for (int i = 0; i < inSize; ++i) {
                sum += mWeights[weightIdx + j * inSize + i] * in[i];
            }
            
            if (layer < mLayerSizes.size() - 1) {
                out[j] = ReLU(sum);
            } else {
                out[j] = Tanh(sum);
            }
        }
        
        actOffset += inSize;
        weightIdx += inSize * outSize;
        biasIdx += outSize;
    }
    
    int outputSize = mLayerSizes.back();
    std::copy(mActivations.end() - outputSize, mActivations.end(), output);
}

void NeuralNetwork::Forward(const float* input, float* output, int batchSize) {
    for (int b = 0; b < batchSize; ++b) {
        Forward(input + b * mLayerSizes[0], output + b * mLayerSizes.back());
    }
}

void NeuralNetwork::ForwardMoLU(const float* input, float* output)
{
    int inputSize = mLayerSizes[0];
    std::copy(input, input + inputSize, mActivations.begin());
    
    int actOffset = 0;
    int weightIdx = 0;
    int biasIdx = 0;
    
    for (size_t layer = 1; layer < mLayerSizes.size(); ++layer) {
        int inSize = mLayerSizes[layer - 1];
        int outSize = mLayerSizes[layer];
        
        const float* in = mActivations.data() + actOffset;
        float* out = mActivations.data() + actOffset + inSize;
        
        for (int j = 0; j < outSize; ++j) {
            float sum = mBiases[biasIdx + j];

            for (int i = 0; i < inSize; ++i) {
                sum += mWeights[weightIdx + j * inSize + i] * in[i];
            }
            
            if (layer < mLayerSizes.size() - 1) {
                out[j] = MoLU(sum);
            } else {
                out[j] = Tanh(sum);
            }
        }
        
        actOffset += inSize;
        weightIdx += inSize * outSize;
        biasIdx += outSize;
    }
    
    int outputSize = mLayerSizes.back();
    std::copy(mActivations.end() - outputSize, mActivations.end(), output);
}

void NeuralNetwork::ForwardMoLU_AVX2_Batch(const float* input, float* output, int batchSize)
{
    for (int b = 0; b < batchSize; ++b)
    {
        ForwardMoLU(input + b * mLayerSizes[0], output + b * mLayerSizes.back());
    }
}

void NeuralNetwork::ForwardODE2VAE(const float* input, float* output, 
                                    SecondOrderLatentMemory& memory, int envIdx)
{
    if (!mHasODE2VAE) {
        Forward(input, output);
        return;
    }

    float* z_pos = memory.GetPosition(envIdx);
    float* z_vel = memory.GetVelocity(envIdx);
    
    AlignedVector32f accel(LATENT_DIM);
    mODE2VAE.ComputeAcceleration(z_pos, z_vel, input, accel.data());
    
    memory.StepDynamicsScalar(accel.data(), envIdx);
    
    std::copy(z_pos, z_pos + mODE2VAE.latentDim, output);
}

void NeuralNetwork::ForwardODE2VAEVectorized(const float* inputs, float* outputs, int numEnvs)
{
    if (!mHasODE2VAE) {
        Forward(inputs, outputs, numEnvs);
        return;
    }

    AlignedVector32f accelerations(LATENT_DIM * NUM_PARALLEL_ENVS);

    for (int env = 0; env < numEnvs; ++env)
    {
        const float* input = inputs + env * mLayerSizes[0];
        float* z_pos = mLatentMemory.GetPosition(env);
        float* z_vel = mLatentMemory.GetVelocity(env);
        float* accel = accelerations.data() + env * mODE2VAE.latentDim;

        mODE2VAE.ComputeAcceleration(z_pos, z_vel, input, accel);
    }

    mLatentMemory.StepDynamicsVectorized(accelerations.data());
    
    for (int env = 0; env < numEnvs; ++env)
    {
        float* z_pos = mLatentMemory.GetPosition(env);
        float* output = outputs + env * mODE2VAE.latentDim;
        std::copy(z_pos, z_pos + mODE2VAE.latentDim, output);
    }
}

void NeuralNetwork::CopyFrom(const NeuralNetwork& other) {
    mWeights = other.mWeights;
    mBiases = other.mBiases;
    mODE2VAE = other.mODE2VAE;
    mHasODE2VAE = other.mHasODE2VAE;
}

void NeuralNetwork::SoftUpdate(const NeuralNetwork& other, float tau) {
    for (size_t i = 0; i < mWeights.size(); ++i) {
        mWeights[i] = (1.0f - tau) * mWeights[i] + tau * other.mWeights[i];
    }
    for (size_t i = 0; i < mBiases.size(); ++i) {
        mBiases[i] = (1.0f - tau) * mBiases[i] + tau * other.mBiases[i];
    }
}

KLPERBuffer::KLPERBuffer(int capacity, int stateDim, int actionDim)
    : mCapacity(capacity)
    , mStateDim(stateDim)
    , mActionDim(actionDim)
{
    mStates.resize(capacity * stateDim);
    mActions.resize(capacity * actionDim);
    mBehaviorLogProbs.resize(capacity);
    mRewards.resize(capacity);
    mNextStates.resize(capacity * stateDim);
    mDones.resize(capacity);
    mPriorities.resize(capacity);
    mKLDivergences.resize(capacity);

    int treeSize = 1;
    while (treeSize < capacity) treeSize *= 2;
    mSumTree.resize(2 * treeSize, 0.0f);
    mMinTree.resize(2 * treeSize, std::numeric_limits<int>::max());
}

void KLPERBuffer::Add(const float* state, const float* action, float behaviorLogProb,
                        const VectorReward& reward, const float* nextState, bool done)
{
    int idx = mIndex * mStateDim;
    std::copy(state, state + mStateDim, mStates.begin() + idx);
    
    idx = mIndex * mActionDim;
    std::copy(action, action + mActionDim, mActions.begin() + idx);
    
    mBehaviorLogProbs[mIndex] = behaviorLogProb;
    mRewards[mIndex] = reward;
    
    idx = mIndex * mStateDim;
    std::copy(nextState, nextState + mStateDim, mNextStates.begin() + idx);
    
    mDones[mIndex] = done ? 1.0f : 0.0f;
    mPriorities[mIndex] = mMaxPriority;
    mKLDivergences[mIndex] = 0.0f;
    
    UpdateTree(mIndex, mMaxPriority);
    
    mIndex = (mIndex + 1) % mCapacity;
    mSize = std::min(mSize + 1, mCapacity);
}

void KLPERBuffer::Sample(int batchSize, float* states, float* actions, float* logProbs,
                          VectorReward* rewards, float* nextStates, float* dones,
                          std::vector<int>& indices, std::mt19937& rng)
{
    indices.resize(batchSize);
    std::uniform_real_distribution<float> dist(0.0f, 1.0f);

    float totalPriority = mSumTree[1];
    float segment = totalPriority / batchSize;

    for (int i = 0; i < batchSize; ++i) {
        float val = segment * (dist(rng) + i);
        int idx = 1;
        
        while (idx < mCapacity) {
            if (mSumTree[2 * idx] >= val) {
                idx = 2 * idx;
            } else {
                val -= mSumTree[2 * idx];
                idx = 2 * idx + 1;
            }
        }
        
        indices[i] = std::min(idx - mCapacity, mSize - 1);
        
        std::copy(mStates.begin() + indices[i] * mStateDim,
                  mStates.begin() + (indices[i] + 1) * mStateDim,
                  states + i * mStateDim);
        
        std::copy(mActions.begin() + indices[i] * mActionDim,
                  mActions.begin() + (indices[i] + 1) * mActionDim,
                  actions + i * mActionDim);
        
        logProbs[i] = mBehaviorLogProbs[indices[i]];
        rewards[i] = mRewards[indices[i]];
        
        std::copy(mNextStates.begin() + indices[i] * mStateDim,
                  mNextStates.begin() + (indices[i] + 1) * mStateDim,
                  nextStates + i * mStateDim);
        
        dones[i] = mDones[indices[i]];
    }
}

void KLPERBuffer::UpdatePriorities(const std::vector<int>& indices, const float* targetLogProbs,
                                    const float* behaviorLogProbs, int batchSize)
{
    for (int i = 0; i < batchSize; ++i) {
        float kl = ComputeKLDivergence(behaviorLogProbs[i], targetLogProbs[i]);
        mKLDivergences[indices[i]] = kl;
        
        float priority = std::pow(kl + 1e-6f, mAlpha);
        mPriorities[indices[i]] = priority;
        mMaxPriority = std::max(mMaxPriority, priority);
        
        UpdateTree(indices[i], priority);
    }
}

void KLPERBuffer::UpdateKLDivergence(int index, float klDiv)
{
    mKLDivergences[index] = klDiv;
    float priority = std::pow(klDiv + 1e-6f, mAlpha);
    mPriorities[index] = priority;
    mMaxPriority = std::max(mMaxPriority, priority);
    UpdateTree(index, priority);
}

float KLPERBuffer::ComputeKLDivergence(float behaviorLogProb, float targetLogProb) const
{
    float p = std::exp(targetLogProb);
    float q = std::exp(behaviorLogProb);
    return p * (targetLogProb - behaviorLogProb);
}

void KLPERBuffer::UpdateTree(int idx, float priority)
{
    idx += mCapacity;
    mSumTree[idx] = priority;
    mMinTree[idx] = static_cast<int>(priority);
    
    while (idx > 1) {
        idx /= 2;
        mSumTree[idx] = mSumTree[2 * idx] + mSumTree[2 * idx + 1];
        mMinTree[idx] = std::min(mMinTree[2 * idx], mMinTree[2 * idx + 1]);
    }
}

float KLPERBuffer::GetPriorityWeight(int idx) const
{
    float minProb = static_cast<float>(mMinTree[1]) / mSumTree[1];
    float maxWeight = std::pow(mSize * minProb, -mBeta);
    float prob = mSumTree[idx + mCapacity] / mSumTree[1];
    float weight = std::pow(mSize * prob, -mBeta);
    return weight / maxWeight;
}

ReplayBuffer::ReplayBuffer(int capacity, int stateDim, int actionDim)
    : mCapacity(capacity)
    , mStateDim(stateDim)
    , mActionDim(actionDim)
{
    mStates.resize(capacity * stateDim);
    mActions.resize(capacity * actionDim);
    mRewards.resize(capacity);
    mNextStates.resize(capacity * stateDim);
    mDones.resize(capacity);
    mVectorRewards.resize(capacity);
}

void ReplayBuffer::Add(const float* state, const float* action, const VectorReward& reward,
                        const float* nextState, bool done)
{
    int idx = mIndex * mStateDim;
    std::copy(state, state + mStateDim, mStates.begin() + idx);
    
    idx = mIndex * mActionDim;
    std::copy(action, action + mActionDim, mActions.begin() + idx);
    
    mVectorRewards[mIndex] = reward;
    mRewards[mIndex] = reward.Scalar();
    
    idx = mIndex * mStateDim;
    std::copy(nextState, nextState + mStateDim, mNextStates.begin() + idx);
    
    mDones[mIndex] = done ? 1.0f : 0.0f;
    
    mIndex = (mIndex + 1) % mCapacity;
    mSize = std::min(mSize + 1, mCapacity);
}

void ReplayBuffer::Add(const float* state, const float* action, float reward,
                        const float* nextState, bool done)
{
    VectorReward vr;
    vr.damage_dealt = reward;
    Add(state, action, vr, nextState, done);
}

void ReplayBuffer::Sample(int batchSize, float* states, float* actions, float* rewards,
                           float* nextStates, float* dones, std::mt19937& rng) {
    std::uniform_int_distribution<int> dist(0, mSize - 1);
    
    for (int i = 0; i < batchSize; ++i) {
        int idx = dist(rng);
        
        std::copy(mStates.begin() + idx * mStateDim,
                  mStates.begin() + (idx + 1) * mStateDim,
                  states + i * mStateDim);
        
        std::copy(mActions.begin() + idx * mActionDim,
                  mActions.begin() + (idx + 1) * mActionDim,
                  actions + i * mActionDim);
        
        rewards[i] = mRewards[idx];
        
        std::copy(mNextStates.begin() + idx * mStateDim,
                  mNextStates.begin() + (idx + 1) * mStateDim,
                  nextStates + i * mStateDim);
        
        dones[i] = mDones[idx];
    }
}

void ReplayBuffer::SampleVectorRewards(int batchSize, float* states, float* actions,
                                        VectorReward* rewards, float* nextStates, float* dones,
                                        std::mt19937& rng)
{
    std::uniform_int_distribution<int> dist(0, mSize - 1);
    
    for (int i = 0; i < batchSize; ++i) {
        int idx = dist(rng);
        
        std::copy(mStates.begin() + idx * mStateDim,
                  mStates.begin() + (idx + 1) * mStateDim,
                  states + i * mStateDim);
        
        std::copy(mActions.begin() + idx * mActionDim,
                  mActions.begin() + (idx + 1) * mActionDim,
                  actions + i * mActionDim);
        
        rewards[i] = mVectorRewards[idx];
        
        std::copy(mNextStates.begin() + idx * mStateDim,
                  mNextStates.begin() + (idx + 1) * mStateDim,
                  nextStates + i * mStateDim);
        
        dones[i] = mDones[idx];
    }
}
--------------------------

--- FILE: src/CombatRobot.h ---
#pragma once

#include <Jolt/Jolt.h>
#include <Jolt/Physics/Body/BodyID.h>
#include <Jolt/Physics/PhysicsSystem.h>
#include <Jolt/Physics/Constraints/SixDOFConstraint.h>
#include <Jolt/Physics/Constraints/SliderConstraint.h>
#include <Jolt/Physics/Collision/GroupFilterTable.h>

#include <string>
#include <vector>
#include <array>
#include <cmath>

constexpr int NUM_SATELLITES = 13;
constexpr int ACTIONS_PER_SATELLITE = 4;
constexpr int REACTION_WHEEL_DIM = 4;
constexpr int ACTIONS_PER_ROBOT = NUM_SATELLITES * ACTIONS_PER_SATELLITE + REACTION_WHEEL_DIM;
constexpr int NUM_LIDAR_RAYS = 10;
constexpr int OBSERVATION_DIM = 240; // 236 actual + 4 padding for AVX2 alignment (32-byte boundary)

struct ForceSensorReading
{
    float impulseMagnitude[NUM_SATELLITES] = {0.0f};
    float jointStress[NUM_SATELLITES] = {0.0f};

    void Reset()
    {
        for (int i = 0; i < NUM_SATELLITES; ++i)
        {
            impulseMagnitude[i] = 0.0f;
            jointStress[i] = 0.0f;
        }
    }
};

struct PIDController
{
    float kp = 50.0f;
    float ki = 0.0f;
    float kd = 10.0f;
    float integral = 0.0f;
    float prevError = 0.0f;

    float Compute(float setpoint, float current, float dt)
    {
        float error = setpoint - current;
        integral += error * dt;
        float derivative = (error - prevError) / dt;
        prevError = error;
        return kp * error + ki * integral + kd * derivative;
    }

    void Reset()
    {
        integral = 0.0f;
        prevError = 0.0f;
    }
};

struct SatelliteData
{
    JPH::BodyID coreBodyId;
    JPH::BodyID spikeBodyId;
    JPH::SixDOFConstraint* rotationJoint = nullptr;
    JPH::SliderConstraint* slideJoint = nullptr;
    PIDController pidX;
    PIDController pidY;
    PIDController pidZ;
    
    float currentSlidePosition = 0.0f;
    float currentAngularVelX = 0.0f;
    float currentAngularVelY = 0.0f;
    float currentAngularVelZ = 0.0f;
};

struct ResidualActionScale
{
    float rotationScale = 50.0f;
    float slideScale = 200.0f;
};

struct CombatRobotData
{
    JPH::BodyID mainBodyId;
    std::array<SatelliteData, NUM_SATELLITES> satellites;
    float hp = 100.0f;

    uint32_t envIndex = 0;
    int robotIndex = 0;
    uint32_t collisionGroup = 0;

    float totalDamageDealt = 0.0f;
    float totalDamageTaken = 0.0f;
    float totalEnergyUsed = 0.0f;
    int episodeSteps = 0;

    ResidualActionScale actionScale;

    std::array<float, ACTIONS_PER_ROBOT> baseActions{};
    std::array<float, ACTIONS_PER_ROBOT> residualActions{};
    std::array<float, ACTIONS_PER_ROBOT> finalActions{};
    
    float observationBuffer[OBSERVATION_DIM];
    float lidarDistances[NUM_LIDAR_RAYS];
};

class CombatRobotLoader
{
public:
    CombatRobotData LoadRobot(
        const std::string& configPath,
        JPH::PhysicsSystem* physicsSystem,
        const JPH::RVec3& position,
        uint32_t envIndex,
        int robotIndex
    );

    void ResetRobot(
        CombatRobotData& robot,
        JPH::PhysicsSystem* physicsSystem,
        const JPH::RVec3& spawnPosition
    );

    void ApplyActions(
        CombatRobotData& robot,
        const float* actions,
        JPH::PhysicsSystem* physicsSystem
    );

    void ApplyResidualActions(
        CombatRobotData& robot,
        const float* residualActions,
        JPH::PhysicsSystem* physicsSystem
    );

    void ComputeBasePIDActions(
        CombatRobotData& robot,
        JPH::PhysicsSystem* physicsSystem,
        float dt
    );

    void GetObservations(
        CombatRobotData& robot,
        const CombatRobotData& opponent,
        float* observations,
        const ForceSensorReading& forces,
        JPH::PhysicsSystem* physicsSystem
    );
    
    void PerformLidarScan(
        CombatRobotData& robot,
        JPH::PhysicsSystem* physicsSystem
    );

private:
    void BlendResidualWithBase(CombatRobotData& robot);
    
    static const JPH::Vec3 mLidarDirections[NUM_LIDAR_RAYS];
    static JPH::Ref<JPH::GroupFilterTable> mGroupFilter;
};

--------------------------

--- FILE: src/CombatRobot.cpp ---
#include <stdexcept>
#include <Jolt/Jolt.h>
#include "CombatRobot.h"

#include <cmath>
#include <fstream>
#include <iostream>
#include <mutex>

#include <nlohmann/json.hpp>
#include <Jolt/Physics/Body/BodyCreationSettings.h>
#include <Jolt/Physics/Body/BodyInterface.h>
#include <Jolt/Physics/Collision/Shape/SphereShape.h>
#include <Jolt/Physics/Collision/Shape/CylinderShape.h>
#include <Jolt/Physics/Collision/RayCast.h>
#include <Jolt/Physics/Collision/CastResult.h>
#include <Jolt/Physics/Collision/PhysicsMaterial.h>
#include <Jolt/Physics/Constraints/SixDOFConstraint.h>
#include <Jolt/Physics/Constraints/SliderConstraint.h>

#include "PhysicsCore.h"

// Define the static member
JPH::Ref<JPH::GroupFilterTable> CombatRobotLoader::mGroupFilter = nullptr;

using json = nlohmann::json;

const JPH::Vec3 CombatRobotLoader::mLidarDirections[NUM_LIDAR_RAYS] = {
    JPH::Vec3(1.0f, 0.0f, 0.0f),
    JPH::Vec3(0.707f, 0.0f, 0.707f),
    JPH::Vec3(0.707f, 0.0f, -0.707f),
    JPH::Vec3(0.5f, 0.0f, 0.866f),
    JPH::Vec3(0.5f, 0.0f, -0.866f),
    JPH::Vec3(0.0f, 0.0f, 1.0f),
    JPH::Vec3(0.0f, 0.0f, -1.0f),
    JPH::Vec3(-1.0f, 0.0f, 0.0f),
    JPH::Vec3(0.0f, 1.0f, 0.0f),
    JPH::Vec3(0.0f, -1.0f, 0.0f)
};

CombatRobotData CombatRobotLoader::LoadRobot(
    const std::string& configPath,
    JPH::PhysicsSystem* physicsSystem,
    const JPH::RVec3& position,
    uint32_t envIndex,
    int robotIndex)
{
    // Force sequential loading to prevent Jolt memory allocator collisions 
    // and JPH::Ref counter corruption from concurrent thread execution.
    static std::mutex sLoadMutex;
    std::lock_guard<std::mutex> lock(sLoadMutex);
    
    CombatRobotData robotData;
    robotData.envIndex = envIndex;
    robotData.robotIndex = robotIndex;
    robotData.hp = 100.0f;
    robotData.totalEnergyUsed = 0.0f;
    robotData.collisionGroup = envIndex * 2 + robotIndex;

    std::ifstream file(configPath);
    if (!file.is_open())
    {
        std::cerr << "[JOLTrl] FATAL: Failed to open " << configPath << std::endl;
        return robotData;
    }

    json config;
    file >> config;

    JPH::BodyInterface& bodyInterface = physicsSystem->GetBodyInterface();

    JPH::ObjectLayer ghostLayer = Layers::MOVING_BASE + envIndex;

    if (mGroupFilter == nullptr)
    {
        mGroupFilter = new JPH::GroupFilterTable(256);
        
        // --- PREVENT INTERNAL EXPLOSIONS ---
        // Disable all self-collisions between parts of the same robot
        for (int i = 0; i < 256; ++i) {
            for (int j = 0; j < 256; ++j) {
                mGroupFilter->DisableCollision(i, j);
            }
        }
        // -----------------------------------
    }

    const float coreRadius = config["core"].value("radius", 0.5f);
    const float coreMass = config["core"].value("mass", 13.0f);
    
    JPH::SphereShapeSettings coreShapeSettings(coreRadius);
    coreShapeSettings.SetDensity(coreMass / (4.0f / 3.0f * 3.14159f * coreRadius * coreRadius * coreRadius));
    
    auto coreResult = coreShapeSettings.Create();
    if (coreResult.HasError()) throw std::runtime_error("Core Shape Error: " + std::string(coreResult.GetError().c_str()));
    JPH::RefConst<JPH::Shape> coreShape = coreResult.Get();

    JPH::BodyCreationSettings coreSettings(
        coreShape,
        position,
        JPH::Quat::sIdentity(),
        JPH::EMotionType::Dynamic,
        ghostLayer
    );

    coreSettings.mFriction = 0.0f;
    coreSettings.mRestitution = 0.8f;
    coreSettings.mLinearDamping = 0.05f;
    coreSettings.mAngularDamping = 0.05f;
    coreSettings.mCollisionGroup.SetGroupFilter(mGroupFilter);
    coreSettings.mCollisionGroup.SetGroupID(robotData.collisionGroup);
    coreSettings.mCollisionGroup.SetSubGroupID(0);

    JPH::Body* coreBody = bodyInterface.CreateBody(coreSettings);
    if (!coreBody) throw std::runtime_error("FATAL: Failed to create body!");
    robotData.mainBodyId = coreBody->GetID();
    bodyInterface.AddBody(robotData.mainBodyId, JPH::EActivation::Activate);

    const auto& satellitesConfig = config["satellites"];
    
    float jointDamping = 0.8f;
    float jointArmature = 0.5f;
    float motorTorque = 450.0f;
    float slideMin = 0.0f;
    float slideMax = 0.5f;
    
    if (config.contains("joints"))
    {
        jointDamping = config["joints"].value("hinge_damping", 0.8f);
        jointArmature = config["joints"].value("hinge_armature", 0.5f);
        motorTorque = config["joints"].value("motor_torque", 450.0f);
        if (config["joints"]["slide_range"].is_array() && config["joints"]["slide_range"].size() >= 2)
        {
            slideMin = config["joints"]["slide_range"][0].get<float>();
            slideMax = config["joints"]["slide_range"][1].get<float>();
        }
    }

    std::cout << "[LoadRobot" << robotIndex << "] Step 5: Entering satellite loop" << std::endl;
    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        std::cout << "[LoadRobot" << robotIndex << "] Step 5." << i << ".1: Processing satellite " << i << std::endl;
        const float azimuth = JPH::DegreesToRadians(satellitesConfig[i].value("offset_angle", 0.0f));
        const float elevation = JPH::DegreesToRadians(satellitesConfig[i].value("elevation", 0.0f));
        const float dist = satellitesConfig[i].value("distance", 1.4f);
        
        JPH::RVec3 satPos = position + JPH::RVec3(
            dist * std::cos(elevation) * std::cos(azimuth),
            dist * std::sin(elevation),
            dist * std::cos(elevation) * std::sin(azimuth)
        );

        const float satRadius = 0.1f;
        const float satMass = 3.5f;
        
        JPH::SphereShapeSettings sphereSettings(satRadius);
        sphereSettings.SetDensity(satMass / (4.0f / 3.0f * 3.14159f * satRadius * satRadius * satRadius));
        
        auto satResult = sphereSettings.Create();
        if (satResult.HasError()) throw std::runtime_error("Sat Shape Error: " + std::string(satResult.GetError().c_str()));
        JPH::RefConst<JPH::Shape> satShape = satResult.Get();

        JPH::BodyCreationSettings satSettings(
            satShape,
            satPos,
            JPH::Quat::sIdentity(),
            JPH::EMotionType::Dynamic,
            ghostLayer
        );

        satSettings.mFriction = 0.0f;
        satSettings.mRestitution = 0.8f;
        satSettings.mLinearDamping = 0.05f;
        satSettings.mAngularDamping = 0.05f;
        satSettings.mCollisionGroup.SetGroupFilter(mGroupFilter);
        satSettings.mCollisionGroup.SetGroupID(robotData.collisionGroup);
        satSettings.mCollisionGroup.SetSubGroupID(i + 1);

        JPH::Body* satBody = bodyInterface.CreateBody(satSettings);
        if (!satBody) throw std::runtime_error("FATAL: Failed to create body!");
        robotData.satellites[i].coreBodyId = satBody->GetID();
        bodyInterface.AddBody(robotData.satellites[i].coreBodyId, JPH::EActivation::Activate);

        JPH::SixDOFConstraintSettings rotSettings;
        rotSettings.mSpace = JPH::EConstraintSpace::WorldSpace;
        rotSettings.mPosition1 = position;
        rotSettings.mPosition2 = position;
        
        rotSettings.mLimitMin[JPH::SixDOFConstraintSettings::EAxis::TranslationX] = 0.0f;
        rotSettings.mLimitMax[JPH::SixDOFConstraintSettings::EAxis::TranslationX] = 0.0f;
        rotSettings.mLimitMin[JPH::SixDOFConstraintSettings::EAxis::TranslationY] = 0.0f;
        rotSettings.mLimitMax[JPH::SixDOFConstraintSettings::EAxis::TranslationY] = 0.0f;
        rotSettings.mLimitMin[JPH::SixDOFConstraintSettings::EAxis::TranslationZ] = 0.0f;
        rotSettings.mLimitMax[JPH::SixDOFConstraintSettings::EAxis::TranslationZ] = 0.0f;
        
        rotSettings.mMotorSettings[JPH::SixDOFConstraintSettings::EAxis::RotationX] = 
            JPH::MotorSettings(motorTorque, jointDamping);
        rotSettings.mMotorSettings[JPH::SixDOFConstraintSettings::EAxis::RotationY] = 
            JPH::MotorSettings(motorTorque, jointDamping);
        rotSettings.mMotorSettings[JPH::SixDOFConstraintSettings::EAxis::RotationZ] = 
            JPH::MotorSettings(motorTorque, jointDamping);

        robotData.satellites[i].rotationJoint = static_cast<JPH::SixDOFConstraint*>(
            bodyInterface.CreateConstraint(&rotSettings, coreBody->GetID(), satBody->GetID()));
        if (!robotData.satellites[i].rotationJoint) throw std::runtime_error("FATAL: Constraint creation returned nullptr!");
        physicsSystem->AddConstraint(robotData.satellites[i].rotationJoint);
        
        robotData.satellites[i].rotationJoint->SetMotorState(
            JPH::SixDOFConstraintSettings::EAxis::RotationX, JPH::EMotorState::Velocity);
        robotData.satellites[i].rotationJoint->SetMotorState(
            JPH::SixDOFConstraintSettings::EAxis::RotationY, JPH::EMotorState::Velocity);
        robotData.satellites[i].rotationJoint->SetMotorState(
            JPH::SixDOFConstraintSettings::EAxis::RotationZ, JPH::EMotorState::Velocity);

        const float spikeHalfHeight = 0.2f;
        const float spikeRadius = 0.02f;
        const float spikeMass = 0.5f;
        
        // MUST specify a custom convex radius (e.g., 0.01f) that is strictly smaller than the spikeRadius (0.02f)
        JPH::CylinderShapeSettings spikeShapeSettings(spikeHalfHeight, spikeRadius, 0.01f);
        spikeShapeSettings.SetDensity(spikeMass / (3.14159f * spikeRadius * spikeRadius * 2.0f * spikeHalfHeight));
        
        auto spikeResult = spikeShapeSettings.Create();
        if (spikeResult.HasError()) throw std::runtime_error("Spike Shape Error: " + std::string(spikeResult.GetError().c_str()));
        JPH::RefConst<JPH::Shape> spikeShape = spikeResult.Get();

        JPH::Vec3 direction = JPH::Vec3(
            std::cos(elevation) * std::cos(azimuth),
            std::sin(elevation),
            std::cos(elevation) * std::sin(azimuth)
        );
        
        JPH::Quat spikeRotation = JPH::Quat::sFromTo(JPH::Vec3::sAxisY(), direction);

        JPH::RVec3 spikePos = satPos + JPH::RVec3(direction * (satRadius + spikeHalfHeight));

        JPH::BodyCreationSettings spikeSettings(
            spikeShape,
            spikePos,
            spikeRotation,
            JPH::EMotionType::Dynamic,
            ghostLayer
        );

        spikeSettings.mFriction = 0.0f;
        spikeSettings.mRestitution = 0.3f;
        spikeSettings.mMotionQuality = JPH::EMotionQuality::LinearCast;
        spikeSettings.mCollisionGroup.SetGroupFilter(mGroupFilter);
        spikeSettings.mCollisionGroup.SetGroupID(robotData.collisionGroup);
        spikeSettings.mCollisionGroup.SetSubGroupID(NUM_SATELLITES + i + 1);

        JPH::Body* spikeBody = bodyInterface.CreateBody(spikeSettings);
        if (!spikeBody) throw std::runtime_error("FATAL: Failed to create body!");
        robotData.satellites[i].spikeBodyId = spikeBody->GetID();
        bodyInterface.AddBody(robotData.satellites[i].spikeBodyId, JPH::EActivation::Activate);

        JPH::SliderConstraintSettings slideSettings;
        slideSettings.mSpace = JPH::EConstraintSpace::WorldSpace;
        slideSettings.mPoint1 = spikePos;
        slideSettings.mPoint2 = spikePos;
        slideSettings.SetSliderAxis(direction);
        slideSettings.mLimitsMin = slideMin;
        slideSettings.mLimitsMax = slideMax;
        slideSettings.mMotorSettings = JPH::MotorSettings(200.0f, 1.0f);

        robotData.satellites[i].slideJoint = static_cast<JPH::SliderConstraint*>(
            bodyInterface.CreateConstraint(&slideSettings, satBody->GetID(), spikeBody->GetID()));
        if (!robotData.satellites[i].slideJoint) throw std::runtime_error("FATAL: Constraint creation returned nullptr!");
        physicsSystem->AddConstraint(robotData.satellites[i].slideJoint);
        
        robotData.satellites[i].slideJoint->SetMotorState(JPH::EMotorState::Velocity);

        robotData.satellites[i].pidX = PIDController{50.0f, 0.0f, 10.0f, 0.0f, 0.0f};
        robotData.satellites[i].pidY = PIDController{50.0f, 0.0f, 10.0f, 0.0f, 0.0f};
        robotData.satellites[i].pidZ = PIDController{50.0f, 0.0f, 10.0f, 0.0f, 0.0f};
    }

    return robotData;
}

void CombatRobotLoader::ResetRobot(
    CombatRobotData& robot,
    JPH::PhysicsSystem* physicsSystem,
    const JPH::RVec3& spawnPosition)
{
    JPH::BodyInterface& bodyInterface = physicsSystem->GetBodyInterface();

    robot.hp = 100.0f;
    robot.totalDamageDealt = 0.0f;
    robot.totalDamageTaken = 0.0f;
    robot.totalEnergyUsed = 0.0f;

    bodyInterface.SetPositionAndRotation(robot.mainBodyId, spawnPosition, JPH::Quat::sIdentity(),
                                         JPH::EActivation::Activate);
    bodyInterface.SetLinearAndAngularVelocity(robot.mainBodyId, JPH::Vec3::sZero(), JPH::Vec3::sZero());

    const float distance = 1.4f;
    
    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        float azimuth, elevation;
        
        switch (i)
        {
            case 0: azimuth = 0.0f; elevation = 0.0f; break;
            case 1: azimuth = 72.0f; elevation = 0.0f; break;
            case 2: azimuth = 144.0f; elevation = 0.0f; break;
            case 3: azimuth = 216.0f; elevation = 0.0f; break;
            case 4: azimuth = 288.0f; elevation = 0.0f; break;
            case 5: azimuth = 0.0f; elevation = 45.0f; break;
            case 6: azimuth = 90.0f; elevation = 45.0f; break;
            case 7: azimuth = 180.0f; elevation = 45.0f; break;
            case 8: azimuth = 270.0f; elevation = 45.0f; break;
            case 9: azimuth = 0.0f; elevation = -45.0f; break;
            case 10: azimuth = 90.0f; elevation = -45.0f; break;
            case 11: azimuth = 180.0f; elevation = -45.0f; break;
            case 12: azimuth = 270.0f; elevation = -45.0f; break;
            default: azimuth = 0.0f; elevation = 0.0f;
        }
        
        azimuth = JPH::DegreesToRadians(azimuth);
        elevation = JPH::DegreesToRadians(elevation);
        
        JPH::RVec3 satPos = spawnPosition + JPH::RVec3(
            distance * std::cos(elevation) * std::cos(azimuth),
            distance * std::sin(elevation),
            distance * std::cos(elevation) * std::sin(azimuth)
        );

        bodyInterface.SetPositionAndRotation(robot.satellites[i].coreBodyId, satPos, JPH::Quat::sIdentity(),
                                             JPH::EActivation::Activate);
        bodyInterface.SetLinearAndAngularVelocity(robot.satellites[i].coreBodyId, JPH::Vec3::sZero(),
                                                  JPH::Vec3::sZero());

        const float satRadius = 0.1f;
        const float spikeHalfHeight = 0.2f;
        
        JPH::Vec3 direction = JPH::Vec3(
            std::cos(elevation) * std::cos(azimuth),
            std::sin(elevation),
            std::cos(elevation) * std::sin(azimuth)
        );
        
        JPH::RVec3 spikePos = satPos + JPH::RVec3(direction * (satRadius + spikeHalfHeight));
        JPH::Quat spikeRotation = JPH::Quat::sFromTo(JPH::Vec3::sAxisY(), direction);

        bodyInterface.SetPositionAndRotation(robot.satellites[i].spikeBodyId, spikePos, spikeRotation,
                                             JPH::EActivation::Activate);
        bodyInterface.SetLinearAndAngularVelocity(robot.satellites[i].spikeBodyId, JPH::Vec3::sZero(),
                                                  JPH::Vec3::sZero());

        robot.satellites[i].pidX.Reset();
        robot.satellites[i].pidY.Reset();
        robot.satellites[i].pidZ.Reset();
        robot.satellites[i].currentSlidePosition = 0.0f;
        robot.satellites[i].currentAngularVelX = 0.0f;
        robot.satellites[i].currentAngularVelY = 0.0f;
        robot.satellites[i].currentAngularVelZ = 0.0f;
    }
}

void CombatRobotLoader::ComputeBasePIDActions(
    CombatRobotData& robot,
    JPH::PhysicsSystem* physicsSystem,
    float dt)
{
    JPH::BodyInterface& bodyInterface = physicsSystem->GetBodyInterface();

    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        JPH::Vec3 angVel = bodyInterface.GetAngularVelocity(robot.satellites[i].coreBodyId);
        
        float torqueX = robot.satellites[i].pidX.Compute(0.0f, angVel.GetX(), dt);
        float torqueY = robot.satellites[i].pidY.Compute(0.0f, angVel.GetY(), dt);
        float torqueZ = robot.satellites[i].pidZ.Compute(0.0f, angVel.GetZ(), dt);

        robot.baseActions[i * ACTIONS_PER_SATELLITE + 0] = torqueX;
        robot.baseActions[i * ACTIONS_PER_SATELLITE + 1] = torqueY;
        robot.baseActions[i * ACTIONS_PER_SATELLITE + 2] = torqueZ;
        robot.baseActions[i * ACTIONS_PER_SATELLITE + 3] = 0.0f;
    }
}

void CombatRobotLoader::BlendResidualWithBase(CombatRobotData& robot)
{
    for (int i = 0; i < ACTIONS_PER_ROBOT; ++i)
    {
        robot.finalActions[i] = robot.baseActions[i] + 
            robot.residualActions[i] * robot.actionScale.rotationScale;
    }
}

void CombatRobotLoader::ApplyActions(
    CombatRobotData& robot,
    const float* actions,
    JPH::PhysicsSystem* physicsSystem)
{
    JPH::BodyInterface& bodyInterface = physicsSystem->GetBodyInterface();
    float energySum = 0.0f;

    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        const float vx = actions[i * ACTIONS_PER_SATELLITE + 0] * robot.actionScale.rotationScale;
        const float vy = actions[i * ACTIONS_PER_SATELLITE + 1] * robot.actionScale.rotationScale;
        const float vz = actions[i * ACTIONS_PER_SATELLITE + 2] * robot.actionScale.rotationScale;
        const float slideVel = actions[i * ACTIONS_PER_SATELLITE + 3] * robot.actionScale.slideScale;

        if (robot.satellites[i].rotationJoint != nullptr)
        {
            robot.satellites[i].rotationJoint->SetTargetVelocityCS(
                JPH::Vec3(vx, vy, vz));
        }

        if (robot.satellites[i].slideJoint != nullptr)
        {
            robot.satellites[i].slideJoint->SetTargetVelocity(slideVel);
        }

        energySum += std::abs(vx) + std::abs(vy) + std::abs(vz) + std::abs(slideVel);
    }

    const float reactionTorqueScale = 450.0f;
    JPH::Vec3 reactionTorque(
        actions[52] * reactionTorqueScale,
        actions[53] * reactionTorqueScale,
        actions[54] * reactionTorqueScale
    );
    bodyInterface.AddTorque(robot.mainBodyId, reactionTorque);

    const float omniSpikeBurst = actions[55] * robot.actionScale.slideScale;
    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        if (robot.satellites[i].slideJoint != nullptr)
        {
            float currentVel = robot.satellites[i].slideJoint->GetTargetVelocity();
            robot.satellites[i].slideJoint->SetTargetVelocity(currentVel + omniSpikeBurst);
        }
    }

    robot.totalEnergyUsed += energySum * 0.001f;
}

void CombatRobotLoader::ApplyResidualActions(
    CombatRobotData& robot,
    const float* residualActions,
    JPH::PhysicsSystem* physicsSystem)
{
    for (int i = 0; i < ACTIONS_PER_ROBOT; ++i)
    {
        robot.residualActions[i] = residualActions[i];
    }

    ComputeBasePIDActions(robot, physicsSystem, 1.0f / 60.0f);
    BlendResidualWithBase(robot);
    ApplyActions(robot, robot.finalActions.data(), physicsSystem);
}

void CombatRobotLoader::PerformLidarScan(
    CombatRobotData& robot,
    JPH::PhysicsSystem* physicsSystem)
{
    JPH::BodyInterface& bodyInterface = physicsSystem->GetBodyInterface();
    
    JPH::RVec3 rootPos = bodyInterface.GetPosition(robot.mainBodyId);
    JPH::Quat rootRot = bodyInterface.GetRotation(robot.mainBodyId);
    
    const float maxDistance = 20.0f;
    
    const JPH::NarrowPhaseQuery& narrowPhaseQuery = physicsSystem->GetNarrowPhaseQuery();
    
    for (int i = 0; i < NUM_LIDAR_RAYS; ++i)
    {
        JPH::Vec3 worldDir = rootRot * mLidarDirections[i];
        
        JPH::RRayCast ray;
        ray.mOrigin = rootPos;
        ray.mDirection = JPH::RVec3(worldDir * maxDistance);
        
        JPH::RayCastResult result;
        
        JPH::IgnoreSingleBodyFilter bodyFilter(robot.mainBodyId);
        
        bool hit = narrowPhaseQuery.CastRay(ray, result, JPH::BroadPhaseLayerFilter(), JPH::ObjectLayerFilter(), bodyFilter);
        
        if (hit)
        {
            robot.lidarDistances[i] = static_cast<float>(result.mFraction * maxDistance);
        }
        else
        {
            robot.lidarDistances[i] = maxDistance;
        }
    }
}

void CombatRobotLoader::GetObservations(
    CombatRobotData& robot,
    const CombatRobotData& opponent,
    float* observations,
    const ForceSensorReading& forces,
    JPH::PhysicsSystem* physicsSystem)
{
    JPH::BodyInterface& bodyInterface = physicsSystem->GetBodyInterface();
    int idx = 0;

    JPH::RVec3 myPos = bodyInterface.GetPosition(robot.mainBodyId);
    JPH::Vec3 myVel = bodyInterface.GetLinearVelocity(robot.mainBodyId);
    JPH::Vec3 myAngVel = bodyInterface.GetAngularVelocity(robot.mainBodyId);
    JPH::Quat myRot = bodyInterface.GetRotation(robot.mainBodyId);

    observations[idx++] = static_cast<float>(myPos.GetX());
    observations[idx++] = static_cast<float>(myPos.GetY());
    observations[idx++] = static_cast<float>(myPos.GetZ());
    observations[idx++] = myVel.GetX();
    observations[idx++] = myVel.GetY();
    observations[idx++] = myVel.GetZ();
    observations[idx++] = myAngVel.GetX();
    observations[idx++] = myAngVel.GetY();
    observations[idx++] = myAngVel.GetZ();

    JPH::RVec3 oppPos = bodyInterface.GetPosition(opponent.mainBodyId);
    JPH::Vec3 oppVel = bodyInterface.GetLinearVelocity(opponent.mainBodyId);
    JPH::RVec3 relPos = oppPos - myPos;

    observations[idx++] = static_cast<float>(relPos.GetX());
    observations[idx++] = static_cast<float>(relPos.GetY());
    observations[idx++] = static_cast<float>(relPos.GetZ());
    observations[idx++] = oppVel.GetX();
    observations[idx++] = oppVel.GetY();
    observations[idx++] = oppVel.GetZ();

    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        JPH::RVec3 pos = bodyInterface.GetPosition(robot.satellites[i].coreBodyId);
        JPH::Vec3 vel = bodyInterface.GetLinearVelocity(robot.satellites[i].coreBodyId);
        JPH::Vec3 angVel = bodyInterface.GetAngularVelocity(robot.satellites[i].coreBodyId);
        
        observations[idx++] = static_cast<float>(pos.GetX());
        observations[idx++] = static_cast<float>(pos.GetY());
        observations[idx++] = static_cast<float>(pos.GetZ());
        observations[idx++] = vel.GetX();
        observations[idx++] = vel.GetY();
        observations[idx++] = vel.GetZ();
        observations[idx++] = angVel.GetX();
        observations[idx++] = angVel.GetY();
        observations[idx++] = angVel.GetZ();
    }

    PerformLidarScan(robot, physicsSystem);
    for (int i = 0; i < NUM_LIDAR_RAYS; ++i)
    {
        observations[idx++] = robot.lidarDistances[i] / 20.0f;
    }

    observations[idx++] = robot.hp / 100.0f;
    observations[idx++] = opponent.hp / 100.0f;
    observations[idx++] = static_cast<float>((oppPos - myPos).Length()) / 20.0f;
    
    JPH::Vec3 myForward = myRot.RotateAxisY();
    JPH::Vec3 toOpponent = (oppPos - myPos).Normalized();
    float facingDot = myForward.Dot(toOpponent);
    observations[idx++] = facingDot;
    
    float healthDiff = (robot.hp - opponent.hp) / 100.0f;
    observations[idx++] = healthDiff;
    
    float mySpeed = myVel.Length();
    float oppSpeed = oppVel.Length();
    observations[idx++] = mySpeed / 10.0f;
    observations[idx++] = oppSpeed / 10.0f;
    
    float speedRatio = (oppSpeed > 0.01f) ? (mySpeed / oppSpeed) : 1.0f;
    observations[idx++] = std::clamp(speedRatio, 0.0f, 5.0f) / 5.0f;
    
    JPH::Vec3 relVel = oppVel - myVel;
    observations[idx++] = relVel.GetX() / 10.0f;
    observations[idx++] = relVel.GetY() / 10.0f;
    observations[idx++] = relVel.GetZ() / 10.0f;
    
    float closingSpeed = -relVel.Dot(toOpponent);
    observations[idx++] = closingSpeed / 10.0f;
    
    JPH::Vec3 crossProduct = myVel.Cross(oppVel);
    observations[idx++] = crossProduct.GetX() / 10.0f;
    observations[idx++] = crossProduct.GetY() / 10.0f;
    observations[idx++] = crossProduct.GetZ() / 10.0f;
    
    observations[idx++] = robot.totalDamageDealt / 100.0f;
    observations[idx++] = robot.totalDamageTaken / 100.0f;
    observations[idx++] = robot.episodeSteps / 1000.0f;
    
    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        observations[idx++] = forces.impulseMagnitude[i];
    }
    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        observations[idx++] = forces.jointStress[i];
    }
    
    for (int i = 0; i < NUM_SATELLITES; ++i)
    {
        JPH::RVec3 satPos = bodyInterface.GetPosition(robot.satellites[i].coreBodyId);
        observations[idx++] = static_cast<float>(satPos.GetY()) / 10.0f;
    }
    
    JPH::Vec3 worldGravity(0.0f, -1.0f, 0.0f);
    JPH::Vec3 localGravity = myRot.Conjugated() * worldGravity;
    observations[idx++] = localGravity.GetX();
    observations[idx++] = localGravity.GetY();
    observations[idx++] = localGravity.GetZ();
    
    constexpr float coreMass = 13.0f;
    observations[idx++] = myAngVel.GetX() * coreMass;
    observations[idx++] = myAngVel.GetY() * coreMass;
    observations[idx++] = myAngVel.GetZ() * coreMass;
    
    observations[idx++] = static_cast<float>(myPos.GetX()) / 100.0f;
    observations[idx++] = static_cast<float>(myPos.GetZ()) / 100.0f;
    
    float dist = static_cast<float>((oppPos - myPos).Length());
    float timeToCollision = dist / std::max(std::abs(closingSpeed), 0.1f);
    observations[idx++] = timeToCollision / 20.0f;
}
--------------------------

--- FILE: src/RobotLoader.h ---
#pragma once

#include <string>
#include <vector>

#include <Jolt/Jolt.h>
#include <Jolt/Physics/Body/BodyID.h>
#include <Jolt/Physics/PhysicsSystem.h>
#include <Jolt/Physics/Constraints/TwoBodyConstraint.h>

struct RobotData
{
    std::vector<JPH::BodyID> bodies;
    std::vector<JPH::TwoBodyConstraint*> constraints;
};

class RobotLoader
{
public:
    RobotData LoadRobot(const std::string& filepath, JPH::PhysicsSystem* physicsSystem);
};

--------------------------

--- FILE: src/RobotLoader.cpp ---
#include <Jolt/Jolt.h>
#include "RobotLoader.h"

#include <cmath>
#include <fstream>
#include <iostream>
#include <map>

#include <nlohmann/json.hpp>

#include <Jolt/Math/Math.h>
#include <Jolt/Physics/Body/BodyCreationSettings.h>
#include <Jolt/Physics/Body/BodyInterface.h>
#include <Jolt/Physics/Collision/Shape/BoxShape.h>
#include <Jolt/Physics/Collision/Shape/SphereShape.h>
#include <Jolt/Physics/Constraints/HingeConstraint.h>

#include "PhysicsCore.h"

RobotData RobotLoader::LoadRobot(const std::string& filepath, JPH::PhysicsSystem* physicsSystem)
{
    RobotData robot_data;

    if (physicsSystem == nullptr) {
        std::cerr << "RobotLoader: PhysicsSystem is null." << std::endl;
        return robot_data;
    }

    std::ifstream file(filepath);
    if (!file.is_open()) {
        std::cerr << "RobotLoader: Failed to open " << filepath << std::endl;
        return robot_data;
    }

    nlohmann::json data;
    file >> data;

    std::map<std::string, JPH::BodyID> body_map;
    JPH::BodyInterface& body_interface = physicsSystem->GetBodyInterface();

    const auto& bodies = data.at("bodies");
    for (const auto& body_data : bodies) {
        const std::string name = body_data.value("name", "");
        const std::string shape = body_data.value("shape", "box");
        const std::string type = body_data.value("type", "dynamic");

        if (name.empty()) {
            std::cerr << "RobotLoader: Body missing name." << std::endl;
            continue;
        }

        const auto& position = body_data.at("position");
        const double px = position.at(0).get<double>();
        const double py = position.at(1).get<double>();
        const double pz = position.at(2).get<double>();

        JPH::Quat rotation = JPH::Quat::sIdentity();
        auto rotation_it = body_data.find("rotation");
        if (rotation_it != body_data.end()) {
            const auto& rot = *rotation_it;
            const float rx = JPH::DegreesToRadians(rot.at(0).get<float>());
            const float ry = JPH::DegreesToRadians(rot.at(1).get<float>());
            const float rz = JPH::DegreesToRadians(rot.at(2).get<float>());
            rotation = JPH::Quat::sEulerAngles(JPH::Vec3(rx, ry, rz));
        }

        const JPH::EMotionType motion_type = (type == "static") ? JPH::EMotionType::Static : JPH::EMotionType::Dynamic;
        const JPH::ObjectLayer layer = (motion_type == JPH::EMotionType::Static) ? Layers::STATIC : Layers::MOVING_BASE;

        JPH::ShapeSettings::ShapeResult shape_result;
        if (shape == "box") {
            const auto& half_extents = body_data.at("half_extents");
            const float hx = half_extents.at(0).get<float>();
            const float hy = half_extents.at(1).get<float>();
            const float hz = half_extents.at(2).get<float>();
            JPH::BoxShapeSettings shape_settings(JPH::Vec3(hx, hy, hz));
            shape_result = shape_settings.Create();
        } else if (shape == "sphere" || shape == "circle") {
            const float radius = body_data.at("radius").get<float>();
            JPH::SphereShapeSettings shape_settings(radius);
            shape_result = shape_settings.Create();
        } else {
            std::cerr << "RobotLoader: Unsupported shape for body '" << name << "': " << shape << std::endl;
            continue;
        }

        if (shape_result.HasError()) {
            std::cerr << "RobotLoader: Shape creation failed for body '" << name << "': " << shape_result.GetError() << std::endl;
            continue;
        }

        JPH::Ref<JPH::Shape> shape_ref = shape_result.Get();
        JPH::BodyCreationSettings body_settings(
            shape_ref,
            JPH::RVec3(px, py, pz),
            rotation,
            motion_type,
            layer
        );

        if (motion_type == JPH::EMotionType::Dynamic) {
            const float mass = body_data.value("mass", 1.0f);
            body_settings.mOverrideMassProperties = JPH::EOverrideMassProperties::CalculateInertia;
            body_settings.mMassPropertiesOverride.mMass = mass;

            body_settings.mFriction = 0.0f;
            body_settings.mRestitution = 1.0f;
            body_settings.mLinearDamping = 0.0f;
            body_settings.mAngularDamping = 0.0f;
        }

        JPH::Body* body = body_interface.CreateBody(body_settings);
        if (body == nullptr) {
            std::cerr << "RobotLoader: Failed to create body '" << name << "'." << std::endl;
            continue;
        }

        const JPH::BodyID body_id = body->GetID();
        body_interface.AddBody(body_id, motion_type == JPH::EMotionType::Dynamic ? JPH::EActivation::Activate : JPH::EActivation::DontActivate);

        body_map[name] = body_id;
        robot_data.bodies.push_back(body_id);
    }

    auto joints_it = data.find("joints");
    if (joints_it != data.end()) {
        for (const auto& joint_data : *joints_it) {
            const std::string type = joint_data.value("type", "");
            if (type != "hinge") {
                std::cerr << "RobotLoader: Unsupported joint type: " << type << std::endl;
                continue;
            }

            const std::string parent_name = joint_data.value("parent", "");
            const std::string child_name = joint_data.value("child", "");

            auto parent_it = body_map.find(parent_name);
            auto child_it = body_map.find(child_name);
            if (parent_it == body_map.end() || child_it == body_map.end()) {
                std::cerr << "RobotLoader: Joint references unknown bodies: " << parent_name << " -> " << child_name << std::endl;
                continue;
            }

            const auto& point = joint_data.at("point");
            const auto& axis = joint_data.at("axis");

            const double px = point.at(0).get<double>();
            const double py = point.at(1).get<double>();
            const double pz = point.at(2).get<double>();

            JPH::Vec3 hinge_axis(
                axis.at(0).get<float>(),
                axis.at(1).get<float>(),
                axis.at(2).get<float>()
            );

            if (hinge_axis.IsNearZero()) {
                hinge_axis = JPH::Vec3::sAxisY();
            } else {
                hinge_axis = hinge_axis.Normalized();
            }

            const float axis_dot_up = std::fabs(hinge_axis.GetY());
            JPH::Vec3 reference = axis_dot_up > 0.9f ? JPH::Vec3::sAxisX() : JPH::Vec3::sAxisY();
            JPH::Vec3 normal_axis = hinge_axis.Cross(reference);
            if (normal_axis.IsNearZero()) {
                normal_axis = hinge_axis.GetNormalizedPerpendicular();
            } else {
                normal_axis = normal_axis.Normalized();
            }

            JPH::HingeConstraintSettings settings;
            settings.mSpace = JPH::EConstraintSpace::WorldSpace;
            settings.mPoint1 = JPH::RVec3(px, py, pz);
            settings.mPoint2 = JPH::RVec3(px, py, pz);
            settings.mHingeAxis1 = hinge_axis;
            settings.mHingeAxis2 = hinge_axis;
            settings.mNormalAxis1 = normal_axis;
            settings.mNormalAxis2 = normal_axis;
            settings.mLimitsMin = -JPH::JPH_PI;
            settings.mLimitsMax = JPH::JPH_PI;
            settings.mLimitsSpringSettings.mFrequency = 0.0f;
            settings.mLimitsSpringSettings.mDamping = 0.0f;
            settings.mMaxFrictionTorque = 0.0f;

            const float motor_speed = joint_data.value("motor_speed", 0.0f);
            const float motor_torque = joint_data.value("motor_torque", 0.0f);
            if (motor_torque > 0.0f) {
                settings.mMotorSettings.mSpringSettings.mFrequency = 10.0f;
                settings.mMotorSettings.mSpringSettings.mDamping = 1.0f;
                settings.mMotorSettings.mMinTorqueLimit = -motor_torque;
                settings.mMotorSettings.mMaxTorqueLimit = motor_torque;
            }

            JPH::TwoBodyConstraint* constraint = body_interface.CreateConstraint(&settings, parent_it->second, child_it->second);
            if (constraint == nullptr) {
                std::cerr << "RobotLoader: Failed to create hinge constraint for joint." << std::endl;
                continue;
            }

            if (motor_torque > 0.0f) {
                JPH::HingeConstraint* hinge = static_cast<JPH::HingeConstraint*>(constraint);
                hinge->SetMotorState(JPH::EMotorState::Velocity);
                hinge->SetTargetAngularVelocity(0.0f);
            }

            physicsSystem->AddConstraint(constraint);
            robot_data.constraints.push_back(constraint);
        }
    }

    return robot_data;
}

--------------------------

--- FILE: robots/combat_bot.json ---
{
  "core": {
    "radius": 0.5,
    "mass": 13.0
  },
  "satellites": [
    { "id": 1, "offset_angle": 0, "elevation": 0, "distance": 1.4 },
    { "id": 2, "offset_angle": 72, "elevation": 0, "distance": 1.4 },
    { "id": 3, "offset_angle": 144, "elevation": 0, "distance": 1.4 },
    { "id": 4, "offset_angle": 216, "elevation": 0, "distance": 1.4 },
    { "id": 5, "offset_angle": 288, "elevation": 0, "distance": 1.4 },
    { "id": 6, "offset_angle": 0, "elevation": 45, "distance": 1.4 },
    { "id": 7, "offset_angle": 90, "elevation": 45, "distance": 1.4 },
    { "id": 8, "offset_angle": 180, "elevation": 45, "distance": 1.4 },
    { "id": 9, "offset_angle": 270, "elevation": 45, "distance": 1.4 },
    { "id": 10, "offset_angle": 0, "elevation": -45, "distance": 1.4 },
    { "id": 11, "offset_angle": 90, "elevation": -45, "distance": 1.4 },
    { "id": 12, "offset_angle": 180, "elevation": -45, "distance": 1.4 },
    { "id": 13, "offset_angle": 270, "elevation": -45, "distance": 1.4 }
  ],
  "joints": {
    "hinge_damping": 0.8,
    "hinge_armature": 0.5,
    "motor_torque": 450.0,
    "slide_range": [0.0, 0.5]
  }
}

--------------------------

--- FILE: mujoco_robot_combat.xml ---
<mujoco>
      <option timestep="0.001" gravity="0 0 -9.8" integrator="RK4" />

      <visual>
            <headlight ambient="0.4 0.3 0.1" diffuse="0.8 0.7 0.5" specular="0.3 0.3 0.3" />
            <rgba fog="0.3 0.22 0.05 1" />
            <quality shadowsize="4096" />
      </visual>

      <statistic extent="10" meansize="0.5" />

      <default>
            <geom friction="1.8 0.1 0.1" solref="0.01 1" solimp="0.9 0.95 0.001" />
            <joint damping="0.8" armature="0.5" />
            <motor gear="450" />
      </default>

      <asset>
            <texture name="grid_tex" type="2d" builtin="checker" width="512" height="512"
                  rgb1="0.1 0.1 0.2" rgb2="0.15 0.15 0.3" />

            <material name="grid_material"
                  texture="grid_tex"
                  texrepeat="10 10"
                  specular="0.2"
                  shininess="0.1"
                  rgba="0.1 0.06 0.04 0" />

            <material name="wall_material"
                  specular="0.5"
                  shininess="0.1"
                  rgba="0.18 0.09 0.06 0" />

            <material name="safety_wall_material" rgba="1 0 0 0" /> <!-- Invisible -->

            <material name="roof_material"
                  specular="0.3"
                  shininess="0.2"
                  rgba="0.2 0.2 0.3 0" />

            <texture name="robot1_tex" type="cube" builtin="flat" width="512" height="512"
                  mark="random" markrgb="1.0 0.2 0.2" />
            <texture name="robot2_tex" type="cube" builtin="flat" width="512" height="512"
                  mark="random" markrgb="0.2 0.2 1.0" />
            <material name="robot1_body_mat" texture="robot1_tex" specular="0.8" shininess="0.9"
                  rgba="1.0 0.55 0.0 1" />
            <material name="robot2_body_mat" texture="robot2_tex" specular="0.8" shininess="0.9"
                  rgba="1.0 0.97 0.86 1" />

            <material name="spike_mat" specular="1.0" shininess="1.0" rgba="0.5 0.5 0.5 1" />
            <material name="yellow_outline" rgba="1 1 0 1" specular="1" shininess="1" emission="1.0" />

            <!-- LED Eye Materials (emissive for glow effect) -->
            <material name="led_eye_red" rgba="1 0 0 1" emission="2.0" specular="0.3" shininess="0.5"/>
            <material name="led_eye_blue" rgba="0 0 1 1" emission="2.0" specular="0.3" shininess="0.5"/>
            <material name="led_eye_green" rgba="0 1 0 1" emission="2.0" specular="0.3" shininess="0.5"/>
            <material name="eye_pupil" rgba="0 0 0 1" emission="0.0" specular="0.1"/>
      </asset>

      <worldbody>
            <light name="main_light" pos="0 0 15" dir="0 0 -1" diffuse="0.9 0.9 1.0"
                  specular="0.5 0.5 0.8" />
            <geom name="floor" type="plane" size="50 50 0.1"
                  material="grid_material"
                  condim="3"
                  friction="1 0.005 0.005" />

            <!-- Thick Outer Arena Walls -->
            <geom name="wall_n" type="box" pos="0 15.0 6.0" size="12.5 2.5 6.0" material="wall_material" />
            <geom name="wall_s" type="box" pos="0 -15.0 6.0" size="12.5 2.5 6.0" material="wall_material" />
            <geom name="wall_e" type="box" pos="15.0 0 6.0" size="2.5 12.5 6.0" material="wall_material" />
            <geom name="wall_w" type="box" pos="-15.0 0 6.0" size="2.5 12.5 6.0" material="wall_material" />
            <geom name="roof" type="box" pos="0 0 12.1" size="17.6 17.6 0.1" material="roof_material" />

            <!-- Rounded Corner Walls -->
            <geom name="corner_ne" type="cylinder" fromto="12.5 12.5 0 12.5 12.5 12" size="2.5" material="wall_material" />
            <geom name="corner_nw" type="cylinder" fromto="-12.5 12.5 0 -12.5 12.5 12" size="2.5" material="wall_material" />
            <geom name="corner_se" type="cylinder" fromto="12.5 -12.5 0 12.5 -12.5 12" size="2.5" material="wall_material" />
            <geom name="corner_sw" type="cylinder" fromto="-12.5 -12.5 0 -12.5 -12.5 12" size="2.5" material="wall_material" />

            <!-- Yellow Arena Outline -->
            <geom name="outline_n_floor" type="box" pos="0 12.0 0.01" size="12.0 0.1 0.01" material="yellow_outline" contype="0" conaffinity="0" />
            <geom name="outline_s_floor" type="box" pos="0 -12.0 0.01" size="12.0 0.1 0.01" material="yellow_outline" contype="0" conaffinity="0" />
            <geom name="outline_e_floor" type="box" pos="12.0 0 0.01" size="0.1 12.0 0.01" material="yellow_outline" contype="0" conaffinity="0" />
            <geom name="outline_w_floor" type="box" pos="-12.0 0 0.01" size="0.1 12.0 0.01" material="yellow_outline" contype="0" conaffinity="0" />
            <!-- Ceiling -->
            <geom name="outline_n_ceil" type="box" pos="0 12.0 12.0" size="12.0 0.1 0.01" material="yellow_outline" contype="0" conaffinity="0" />
            <geom name="outline_s_ceil" type="box" pos="0 -12.0 12.0" size="12.0 0.1 0.01" material="yellow_outline" contype="0" conaffinity="0" />
            <geom name="outline_e_ceil" type="box" pos="12.0 0 12.0" size="0.1 12.0 0.01" material="yellow_outline" contype="0" conaffinity="0" />
            <geom name="outline_w_ceil" type="box" pos="-12.0 0 12.0" size="0.1 12.0 0.01" material="yellow_outline" contype="0" conaffinity="0" />
            <!-- Vertical Pillars -->
            <geom name="outline_ne_pillar" type="box" pos="12.0 12.0 6.0" size="0.1 0.1 6.0" material="yellow_outline" contype="0" conaffinity="0" />
            <geom name="outline_nw_pillar" type="box" pos="-12.0 12.0 6.0" size="0.1 0.1 6.0" material="yellow_outline" contype="0" conaffinity="0" />
            <geom name="outline_se_pillar" type="box" pos="12.0 -12.0 6.0" size="0.1 0.1 6.0" material="yellow_outline" contype="0" conaffinity="0" />
            <geom name="outline_sw_pillar" type="box" pos="-12.0 -12.0 6.0" size="0.1 0.1 6.0" material="yellow_outline" contype="0" conaffinity="0" />


            <!-- Robot 1 (Bright Red) -->
            <body name="robot1" pos="-3.3 0 0.7">
                  <freejoint name="r1_root" />
                  <geom name="r1_body" type="sphere" size="0.5"
                        material="robot1_body_mat"
                        mass="13" />
                  <site name="r1_center" pos="0 0 0" size="0.01" rgba="1 0 0 1"/>
                  <site name="r1_ray_fwd_site" pos="0 0 0" size="0.01" euler="0 0 0"/>
                  <site name="r1_ray_fwd_l_site" pos="0 0 0" size="0.01" euler="0 0 22.5"/>
                  <site name="r1_ray_fwd_r_site" pos="0 0 0" size="0.01" euler="0 0 -22.5"/>
                  <site name="r1_ray_45_l_site" pos="0 0 0" size="0.01" euler="0 0 45"/>
                  <site name="r1_ray_45_r_site" pos="0 0 0" size="0.01" euler="0 0 -45"/>
                  <site name="r1_ray_90_l_site" pos="0 0 0" size="0.01" euler="0 0 90"/>
                  <site name="r1_ray_90_r_site" pos="0 0 0" size="0.01" euler="0 0 -90"/>
                  <site name="r1_ray_back_site" pos="0 0 0" size="0.01" euler="0 0 180"/>
                  <site name="r1_ray_down_site" pos="0 0 0" size="0.01" euler="0 -90 0"/>
                  <site name="r1_ray_up_site" pos="0 0 0" size="0.01" euler="0 90 0"/>

                  <!-- Satellites R1 -->
                  <body name="r1_s1" pos="0 0 0">
                        <joint name="r1_s1y" type="hinge" axis="0 0 1" />
                        <joint name="r1_s1p" type="hinge" axis="0 1 0" />
                        <joint name="r1_s1r" type="hinge" axis="1 0 0" />
                        <geom name="r1_sat1_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot1_body_mat" mass="3.5" />
                        <body name="r1_s1_lancer" pos="1.4 0 0">
                            <joint name="r1_s1_slide" type="slide" axis="1 0 0" range="0 0.5"/>
                            <geom name="r1_sat1_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5" />
                            <site name="r1_s1_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5" />
                        </body>
                  </body>
                  <body name="r1_s2" pos="0 0 0">
                        <joint name="r1_s2y" type="hinge" axis="0 0 1" />
                        <joint name="r1_s2p" type="hinge" axis="0 1 0" />
                        <joint name="r1_s2r" type="hinge" axis="1 0 0" />
                        <geom name="r1_sat2_core" type="sphere" pos="-0.9 0 0" size="0.1" material="robot1_body_mat" mass="3.5" />
                        <body name="r1_s2_lancer" pos="-0.9 0 0">
                            <joint name="r1_s2_slide" type="slide" axis="-1 0 0" range="0 0.5"/>
                            <geom name="r1_sat2_spike" type="cylinder" fromto="0 0 0 -0.4 0 0" size="0.02" material="spike_mat" mass="0.5" />
                            <site name="r1_s2_site" pos="-0.4 0 0" size="0.03" rgba="1 1 1 0.5" />
                        </body>
                  </body>
                  <body name="r1_s3" pos="0 0 0">
                        <joint name="r1_s3y" type="hinge" axis="0 0 1" />
                        <joint name="r1_s3p" type="hinge" axis="1 0 0" />
                        <joint name="r1_s3r" type="hinge" axis="0 1 0" />
                        <geom name="r1_sat3_core" type="sphere" pos="0 1.4 0" size="0.1" material="robot1_body_mat" mass="3.5" />
                        <body name="r1_s3_lancer" pos="0 1.4 0">
                            <joint name="r1_s3_slide" type="slide" axis="0 1 0" range="0 0.5"/>
                            <geom name="r1_sat3_spike" type="cylinder" fromto="0 0 0 0 0.4 0" size="0.02" material="spike_mat" mass="0.5" />
                            <site name="r1_s3_site" pos="0 0.4 0" size="0.03" rgba="1 1 1 0.5" />
                        </body>
                  </body>
                  <body name="r1_s4" pos="0 0 0">
                        <joint name="r1_s4y" type="hinge" axis="0 0 1" />
                        <joint name="r1_s4p" type="hinge" axis="1 0 0" />
                        <joint name="r1_s4r" type="hinge" axis="0 1 0" />
                        <geom name="r1_sat4_core" type="sphere" pos="0 -0.9 0" size="0.1" material="robot1_body_mat" mass="3.5" />
                        <body name="r1_s4_lancer" pos="0 -0.9 0">
                            <joint name="r1_s4_slide" type="slide" axis="0 -1 0" range="0 0.5"/>
                            <geom name="r1_sat4_spike" type="cylinder" fromto="0 0 0 0 -0.4 0" size="0.02" material="spike_mat" mass="0.5" />
                            <site name="r1_s4_site" pos="0 -0.4 0" size="0.03" rgba="1 1 1 0.5" />
                        </body>
                  </body>
                  <!-- New Satellites s5-s13 -->
                  <body name="r1_s5" pos="0 0 0" euler="0 -45 0">
                      <joint name="r1_s5y" type="hinge" axis="0 0 1"/><joint name="r1_s5p" type="hinge" axis="0 1 0"/><joint name="r1_s5r" type="hinge" axis="1 0 0"/>
                      <geom name="r1_sat5_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot1_body_mat" mass="3.5"/>
                      <body name="r1_s5_lancer" pos="1.4 0 0"><joint name="r1_s5_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r1_sat5_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r1_s5_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r1_s6" pos="0 0 0" euler="0 -45 72">
                      <joint name="r1_s6y" type="hinge" axis="0 0 1"/><joint name="r1_s6p" type="hinge" axis="0 1 0"/><joint name="r1_s6r" type="hinge" axis="1 0 0"/>
                      <geom name="r1_sat6_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot1_body_mat" mass="3.5"/>
                      <body name="r1_s6_lancer" pos="1.4 0 0"><joint name="r1_s6_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r1_sat6_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r1_s6_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r1_s7" pos="0 0 0" euler="0 -45 144">
                      <joint name="r1_s7y" type="hinge" axis="0 0 1"/><joint name="r1_s7p" type="hinge" axis="0 1 0"/><joint name="r1_s7r" type="hinge" axis="1 0 0"/>
                      <geom name="r1_sat7_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot1_body_mat" mass="3.5"/>
                      <body name="r1_s7_lancer" pos="1.4 0 0"><joint name="r1_s7_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r1_sat7_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r1_s7_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r1_s8" pos="0 0 0" euler="0 -45 216">
                      <joint name="r1_s8y" type="hinge" axis="0 0 1"/><joint name="r1_s8p" type="hinge" axis="0 1 0"/><joint name="r1_s8r" type="hinge" axis="1 0 0"/>
                      <geom name="r1_sat8_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot1_body_mat" mass="3.5"/>
                      <body name="r1_s8_lancer" pos="1.4 0 0"><joint name="r1_s8_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r1_sat8_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r1_s8_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r1_s9" pos="0 0 0" euler="0 -45 288">
                      <joint name="r1_s9y" type="hinge" axis="0 0 1"/><joint name="r1_s9p" type="hinge" axis="0 1 0"/><joint name="r1_s9r" type="hinge" axis="1 0 0"/>
                      <geom name="r1_sat9_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot1_body_mat" mass="3.5"/>
                      <body name="r1_s9_lancer" pos="1.4 0 0"><joint name="r1_s9_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r1_sat9_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r1_s9_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r1_s10" pos="0 0 0" euler="0 45 45">
                      <joint name="r1_s10y" type="hinge" axis="0 0 1"/><joint name="r1_s10p" type="hinge" axis="0 1 0"/><joint name="r1_s10r" type="hinge" axis="1 0 0"/>
                      <geom name="r1_sat10_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot1_body_mat" mass="3.5"/>
                      <body name="r1_s10_lancer" pos="1.4 0 0"><joint name="r1_s10_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r1_sat10_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r1_s10_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r1_s11" pos="0 0 0" euler="0 45 135">
                      <joint name="r1_s11y" type="hinge" axis="0 0 1"/><joint name="r1_s11p" type="hinge" axis="0 1 0"/><joint name="r1_s11r" type="hinge" axis="1 0 0"/>
                      <geom name="r1_sat11_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot1_body_mat" mass="3.5"/>
                      <body name="r1_s11_lancer" pos="1.4 0 0"><joint name="r1_s11_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r1_sat11_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r1_s11_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r1_s12" pos="0 0 0" euler="0 45 225">
                      <joint name="r1_s12y" type="hinge" axis="0 0 1"/><joint name="r1_s12p" type="hinge" axis="0 1 0"/><joint name="r1_s12r" type="hinge" axis="1 0 0"/>
                      <geom name="r1_sat12_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot1_body_mat" mass="3.5"/>
                      <body name="r1_s12_lancer" pos="1.4 0 0"><joint name="r1_s12_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r1_sat12_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r1_s12_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r1_s13" pos="0 0 0" euler="0 45 315">
                      <joint name="r1_s13y" type="hinge" axis="0 0 1"/><joint name="r1_s13p" type="hinge" axis="0 1 0"/><joint name="r1_s13r" type="hinge" axis="1 0 0"/>
                      <geom name="r1_sat13_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot1_body_mat" mass="3.5"/>
                      <body name="r1_s13_lancer" pos="1.4 0 0"><joint name="r1_s13_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r1_sat13_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r1_s13_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>

                  <!-- LED Eye Assemblies for Robot 1 -->
                  <!-- Left Eye Assembly -->
                  <body name="r1_eye_left_base" pos="0.3 0.2 0.1">
                        <joint name="r1_eye_yaw_left" type="hinge" axis="0 0 1" range="-45 45"/>
                        <joint name="r1_eye_pitch_left" type="hinge" axis="0 1 0" range="-30 30"/>
                        <geom name="r1_eye_geom_left" type="sphere" size="0.2" material="led_eye_red" contype="0" conaffinity="0"/>
                        <geom name="r1_pupil_left" type="sphere" pos="0.08 0 0.08" size="0.06" material="eye_pupil" contype="0" conaffinity="0"/>
                  </body>

                  <!-- Right Eye Assembly (mirrored) -->
                  <body name="r1_eye_right_base" pos="0.3 -0.2 0.1">
                        <joint name="r1_eye_yaw_right" type="hinge" axis="0 0 1" range="-45 45"/>
                        <joint name="r1_eye_pitch_right" type="hinge" axis="0 1 0" range="-30 30"/>
                        <geom name="r1_eye_geom_right" type="sphere" size="0.2" material="led_eye_red" contype="0" conaffinity="0"/>
                        <geom name="r1_pupil_right" type="sphere" pos="0.08 0 0.08" size="0.06" material="eye_pupil" contype="0" conaffinity="0"/>
                  </body>
            </body>

            <!-- Robot 2 (Bright Blue) -->
            <body name="robot2" pos="3.3 0 0.7">
                  <freejoint name="r2_root" />
                  <geom name="r2_body" type="sphere" size="0.5" material="robot2_body_mat" mass="13" />
                  <site name="r2_center" pos="0 0 0" size="0.01" rgba="0 0 1 1"/>
                  <site name="r2_ray_fwd_site" pos="0 0 0" size="0.01" euler="0 0 180"/>
                  <site name="r2_ray_fwd_l_site" pos="0 0 0" size="0.01" euler="0 0 157.5"/>
                  <site name="r2_ray_fwd_r_site" pos="0 0 0" size="0.01" euler="0 0 202.5"/>
                  <site name="r2_ray_45_l_site" pos="0 0 0" size="0.01" euler="0 0 135"/>
                  <site name="r2_ray_45_r_site" pos="0 0 0" size="0.01" euler="0 0 225"/>
                  <site name="r2_ray_90_l_site" pos="0 0 0" size="0.01" euler="0 0 90"/>
                  <site name="r2_ray_90_r_site" pos="0 0 0" size="0.01" euler="0 0 -90"/>
                  <site name="r2_ray_back_site" pos="0 0 0" size="0.01" euler="0 0 0"/>
                  <site name="r2_ray_down_site" pos="0 0 0" size="0.01" euler="0 -90 0"/>
                  <site name="r2_ray_up_site" pos="0 0 0" size="0.01" euler="0 90 0"/>

                  <!-- Satellites R2 -->
                  <body name="r2_s1" pos="0 0 0">
                        <joint name="r2_s1y" type="hinge" axis="0 0 1" />
                        <joint name="r2_s1p" type="hinge" axis="0 1 0" />
                        <joint name="r2_s1r" type="hinge" axis="1 0 0" />
                        <geom name="r2_sat1_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot2_body_mat" mass="3.5" />
                        <body name="r2_s1_lancer" pos="1.4 0 0">
                            <joint name="r2_s1_slide" type="slide" axis="1 0 0" range="0 0.5"/>
                            <geom name="r2_sat1_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5" />
                            <site name="r2_s1_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5" />
                        </body>
                  </body>
                  <body name="r2_s2" pos="0 0 0">
                        <joint name="r2_s2y" type="hinge" axis="0 0 1" />
                        <joint name="r2_s2p" type="hinge" axis="0 1 0" />
                        <joint name="r2_s2r" type="hinge" axis="1 0 0" />
                        <geom name="r2_sat2_core" type="sphere" pos="-0.9 0 0" size="0.1" material="robot2_body_mat" mass="3.5" />
                        <body name="r2_s2_lancer" pos="-0.9 0 0">
                            <joint name="r2_s2_slide" type="slide" axis="-1 0 0" range="0 0.5"/>
                            <geom name="r2_sat2_spike" type="cylinder" fromto="0 0 0 -0.4 0 0" size="0.02" material="spike_mat" mass="0.5" />
                            <site name="r2_s2_site" pos="-0.4 0 0" size="0.03" rgba="1 1 1 0.5" />
                        </body>
                  </body>
                  <body name="r2_s3" pos="0 0 0">
                        <joint name="r2_s3y" type="hinge" axis="0 0 1" />
                        <joint name="r2_s3p" type="hinge" axis="1 0 0" />
                        <joint name="r2_s3r" type="hinge" axis="0 1 0" />
                        <geom name="r2_sat3_core" type="sphere" pos="0 1.4 0" size="0.1" material="robot2_body_mat" mass="3.5" />
                        <body name="r2_s3_lancer" pos="0 1.4 0">
                            <joint name="r2_s3_slide" type="slide" axis="0 1 0" range="0 0.5"/>
                            <geom name="r2_sat3_spike" type="cylinder" fromto="0 0 0 0 0.4 0" size="0.02" material="spike_mat" mass="0.5" />
                            <site name="r2_s3_site" pos="0 0.4 0" size="0.03" rgba="1 1 1 0.5" />
                        </body>
                  </body>
                  <body name="r2_s4" pos="0 0 0">
                        <joint name="r2_s4y" type="hinge" axis="0 0 1" />
                        <joint name="r2_s4p" type="hinge" axis="1 0 0" />
                        <joint name="r2_s4r" type="hinge" axis="0 1 0" />
                        <geom name="r2_sat4_core" type="sphere" pos="0 -0.9 0" size="0.1" material="robot2_body_mat" mass="3.5" />
                        <body name="r2_s4_lancer" pos="0 -0.9 0">
                            <joint name="r2_s4_slide" type="slide" axis="0 -1 0" range="0 0.5"/>
                            <geom name="r2_sat4_spike" type="cylinder" fromto="0 0 0 0 -0.4 0" size="0.02" material="spike_mat" mass="0.5" />
                            <site name="r2_s4_site" pos="0 -0.4 0" size="0.03" rgba="1 1 1 0.5" />
                        </body>
                  </body>
                  <!-- New Satellites s5-s13 for R2 -->
                  <body name="r2_s5" pos="0 0 0" euler="0 -45 0">
                      <joint name="r2_s5y" type="hinge" axis="0 0 1"/><joint name="r2_s5p" type="hinge" axis="0 1 0"/><joint name="r2_s5r" type="hinge" axis="1 0 0"/>
                      <geom name="r2_sat5_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot2_body_mat" mass="3.5"/>
                      <body name="r2_s5_lancer" pos="1.4 0 0"><joint name="r2_s5_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r2_sat5_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r2_s5_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r2_s6" pos="0 0 0" euler="0 -45 72">
                      <joint name="r2_s6y" type="hinge" axis="0 0 1"/><joint name="r2_s6p" type="hinge" axis="0 1 0"/><joint name="r2_s6r" type="hinge" axis="1 0 0"/>
                      <geom name="r2_sat6_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot2_body_mat" mass="3.5"/>
                      <body name="r2_s6_lancer" pos="1.4 0 0"><joint name="r2_s6_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r2_sat6_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r2_s6_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r2_s7" pos="0 0 0" euler="0 -45 144">
                      <joint name="r2_s7y" type="hinge" axis="0 0 1"/><joint name="r2_s7p" type="hinge" axis="0 1 0"/><joint name="r2_s7r" type="hinge" axis="1 0 0"/>
                      <geom name="r2_sat7_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot2_body_mat" mass="3.5"/>
                      <body name="r2_s7_lancer" pos="1.4 0 0"><joint name="r2_s7_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r2_sat7_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r2_s7_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r2_s8" pos="0 0 0" euler="0 -45 216">
                      <joint name="r2_s8y" type="hinge" axis="0 0 1"/><joint name="r2_s8p" type="hinge" axis="0 1 0"/><joint name="r2_s8r" type="hinge" axis="1 0 0"/>
                      <geom name="r2_sat8_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot2_body_mat" mass="3.5"/>
                      <body name="r2_s8_lancer" pos="1.4 0 0"><joint name="r2_s8_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r2_sat8_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r2_s8_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r2_s9" pos="0 0 0" euler="0 -45 288">
                      <joint name="r2_s9y" type="hinge" axis="0 0 1"/><joint name="r2_s9p" type="hinge" axis="0 1 0"/><joint name="r2_s9r" type="hinge" axis="1 0 0"/>
                      <geom name="r2_sat9_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot2_body_mat" mass="3.5"/>
                      <body name="r2_s9_lancer" pos="1.4 0 0"><joint name="r2_s9_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r2_sat9_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r2_s9_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r2_s10" pos="0 0 0" euler="0 45 45">
                      <joint name="r2_s10y" type="hinge" axis="0 0 1"/><joint name="r2_s10p" type="hinge" axis="0 1 0"/><joint name="r2_s10r" type="hinge" axis="1 0 0"/>
                      <geom name="r2_sat10_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot2_body_mat" mass="3.5"/>
                      <body name="r2_s10_lancer" pos="1.4 0 0"><joint name="r2_s10_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r2_sat10_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r2_s10_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r2_s11" pos="0 0 0" euler="0 45 135">
                      <joint name="r2_s11y" type="hinge" axis="0 0 1"/><joint name="r2_s11p" type="hinge" axis="0 1 0"/><joint name="r2_s11r" type="hinge" axis="1 0 0"/>
                      <geom name="r2_sat11_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot2_body_mat" mass="3.5"/>
                      <body name="r2_s11_lancer" pos="1.4 0 0"><joint name="r2_s11_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r2_sat11_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r2_s11_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r2_s12" pos="0 0 0" euler="0 45 225">
                      <joint name="r2_s12y" type="hinge" axis="0 0 1"/><joint name="r2_s12p" type="hinge" axis="0 1 0"/><joint name="r2_s12r" type="hinge" axis="1 0 0"/>
                      <geom name="r2_sat12_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot2_body_mat" mass="3.5"/>
                      <body name="r2_s12_lancer" pos="1.4 0 0"><joint name="r2_s12_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r2_sat12_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r2_s12_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>
                  <body name="r2_s13" pos="0 0 0" euler="0 45 315">
                      <joint name="r2_s13y" type="hinge" axis="0 0 1"/><joint name="r2_s13p" type="hinge" axis="0 1 0"/><joint name="r2_s13r" type="hinge" axis="1 0 0"/>
                      <geom name="r2_sat13_core" type="sphere" pos="1.4 0 0" size="0.1" material="robot2_body_mat" mass="3.5"/>
                      <body name="r2_s13_lancer" pos="1.4 0 0"><joint name="r2_s13_slide" type="slide" axis="1 0 0" range="0 0.5"/><geom name="r2_sat13_spike" type="cylinder" fromto="0 0 0 0.4 0 0" size="0.02" material="spike_mat" mass="0.5"/><site name="r2_s13_site" pos="0.4 0 0" size="0.03" rgba="1 1 1 0.5"/></body>
                  </body>

                  <!-- LED Eye Assemblies for Robot 2 -->
                  <!-- Left Eye Assembly -->
                  <body name="r2_eye_left_base" pos="0.3 0.2 0.1">
                        <joint name="r2_eye_yaw_left" type="hinge" axis="0 0 1" range="-45 45"/>
                        <joint name="r2_eye_pitch_left" type="hinge" axis="0 1 0" range="-30 30"/>
                        <geom name="r2_eye_geom_left" type="sphere" size="0.2" material="led_eye_blue" contype="0" conaffinity="0"/>
                        <geom name="r2_pupil_left" type="sphere" pos="0.08 0 0.08" size="0.06" material="eye_pupil" contype="0" conaffinity="0"/>
                  </body>

                  <!-- Right Eye Assembly (mirrored) -->
                  <body name="r2_eye_right_base" pos="0.3 -0.2 0.1">
                        <joint name="r2_eye_yaw_right" type="hinge" axis="0 0 1" range="-45 45"/>
                        <joint name="r2_eye_pitch_right" type="hinge" axis="0 1 0" range="-30 30"/>
                        <geom name="r2_eye_geom_right" type="sphere" size="0.2" material="led_eye_blue" contype="0" conaffinity="0"/>
                        <geom name="r2_pupil_right" type="sphere" pos="0.08 0 0.08" size="0.06" material="eye_pupil" contype="0" conaffinity="0"/>
                  </body>
            </body>
      </worldbody>

      <actuator>
            <!-- R1 Actuators (16) -->
            <motor name="r1m1y" joint="r1_s1y" /> <motor name="r1m1p" joint="r1_s1p" /> <motor name="r1m1r" joint="r1_s1r" /> <motor name="r1m1s" joint="r1_s1_slide" />
            <motor name="r1m2y" joint="r1_s2y" /> <motor name="r1m2p" joint="r1_s2p" /> <motor name="r1m2r" joint="r1_s2r" /> <motor name="r1m2s" joint="r1_s2_slide" />
            <motor name="r1m3y" joint="r1_s3y" /> <motor name="r1m3p" joint="r1_s3p" /> <motor name="r1m3r" joint="r1_s3r" /> <motor name="r1m3s" joint="r1_s3_slide" />
            <motor name="r1m4y" joint="r1_s4y" /> <motor name="r1m4p" joint="r1_s4p" /> <motor name="r1m4r" joint="r1_s4r" /> <motor name="r1m4s" joint="r1_s4_slide" />
            <motor name="r1m5y" joint="r1_s5y" /> <motor name="r1m5p" joint="r1_s5p" /> <motor name="r1m5r" joint="r1_s5r" /> <motor name="r1m5s" joint="r1_s5_slide" />
            <motor name="r1m6y" joint="r1_s6y" /> <motor name="r1m6p" joint="r1_s6p" /> <motor name="r1m6r" joint="r1_s6r" /> <motor name="r1m6s" joint="r1_s6_slide" />
            <motor name="r1m7y" joint="r1_s7y" /> <motor name="r1m7p" joint="r1_s7p" /> <motor name="r1m7r" joint="r1_s7r" /> <motor name="r1m7s" joint="r1_s7_slide" />
            <motor name="r1m8y" joint="r1_s8y" /> <motor name="r1m8p" joint="r1_s8p" /> <motor name="r1m8r" joint="r1_s8r" /> <motor name="r1m8s" joint="r1_s8_slide" />
            <motor name="r1m9y" joint="r1_s9y" /> <motor name="r1m9p" joint="r1_s9p" /> <motor name="r1m9r" joint="r1_s9r" /> <motor name="r1m9s" joint="r1_s9_slide" />
            <motor name="r1m10y" joint="r1_s10y" /> <motor name="r1m10p" joint="r1_s10p" /> <motor name="r1m10r" joint="r1_s10r" /> <motor name="r1m10s" joint="r1_s10_slide" />
            <motor name="r1m11y" joint="r1_s11y" /> <motor name="r1m11p" joint="r1_s11p" /> <motor name="r1m11r" joint="r1_s11r" /> <motor name="r1m11s" joint="r1_s11_slide" />
            <motor name="r1m12y" joint="r1_s12y" /> <motor name="r1m12p" joint="r1_s12p" /> <motor name="r1m12r" joint="r1_s12r" /> <motor name="r1m12s" joint="r1_s12_slide" />
            <motor name="r1m13y" joint="r1_s13y" /> <motor name="r1m13p" joint="r1_s13p" /> <motor name="r1m13r" joint="r1_s13r" /> <motor name="r1m13s" joint="r1_s13_slide" />
            <!-- R2 Actuators (16) -->
            <motor name="r2m1y" joint="r2_s1y" /> <motor name="r2m1p" joint="r2_s1p" /> <motor name="r2m1r" joint="r2_s1r" /> <motor name="r2m1s" joint="r2_s1_slide" />
            <motor name="r2m2y" joint="r2_s2y" /> <motor name="r2m2p" joint="r2_s2p" /> <motor name="r2m2r" joint="r2_s2r" /> <motor name="r2m2s" joint="r2_s2_slide" />
            <motor name="r2m3y" joint="r2_s3y" /> <motor name="r2m3p" joint="r2_s3p" /> <motor name="r2m3r" joint="r2_s3r" /> <motor name="r2m3s" joint="r2_s3_slide" />
            <motor name="r2m4y" joint="r2_s4y" /> <motor name="r2m4p" joint="r2_s4p" /> <motor name="r2m4r" joint="r2_s4r" /> <motor name="r2m4s" joint="r2_s4_slide" />
            <motor name="r2m5y" joint="r2_s5y" /> <motor name="r2m5p" joint="r2_s5p" /> <motor name="r2m5r" joint="r2_s5r" /> <motor name="r2m5s" joint="r2_s5_slide" />
            <motor name="r2m6y" joint="r2_s6y" /> <motor name="r2m6p" joint="r2_s6p" /> <motor name="r2m6r" joint="r2_s6r" /> <motor name="r2m6s" joint="r2_s6_slide" />
            <motor name="r2m7y" joint="r2_s7y" /> <motor name="r2m7p" joint="r2_s7p" /> <motor name="r2m7r" joint="r2_s7r" /> <motor name="r2m7s" joint="r2_s7_slide" />
            <motor name="r2m8y" joint="r2_s8y" /> <motor name="r2m8p" joint="r2_s8p" /> <motor name="r2m8r" joint="r2_s8r" /> <motor name="r2m8s" joint="r2_s8_slide" />
            <motor name="r2m9y" joint="r2_s9y" /> <motor name="r2m9p" joint="r2_s9p" /> <motor name="r2m9r" joint="r2_s9r" /> <motor name="r2m9s" joint="r2_s9_slide" />
            <motor name="r2m10y" joint="r2_s10y" /> <motor name="r2m10p" joint="r2_s10p" /> <motor name="r2m10r" joint="r2_s10r" /> <motor name="r2m10s" joint="r2_s10_slide" />
            <motor name="r2m11y" joint="r2_s11y" /> <motor name="r2m11p" joint="r2_s11p" /> <motor name="r2m11r" joint="r2_s11r" /> <motor name="r2m11s" joint="r2_s11_slide" />
            <motor name="r2m12y" joint="r2_s12y" /> <motor name="r2m12p" joint="r2_s12p" /> <motor name="r2m12r" joint="r2_s12r" /> <motor name="r2m12s" joint="r2_s12_slide" />
            <motor name="r2m13y" joint="r2_s13y" /> <motor name="r2m13p" joint="r2_s13p" /> <motor name="r2m13r" joint="r2_s13r" /> <motor name="r2m13s" joint="r2_s13_slide" />

            <!-- Eye control actuators (separate from RL control, indices 52+) -->
            <!-- Robot 1 Eye Actuators -->
            <position name="r1_eye_yaw_left_act" joint="r1_eye_yaw_left" gear="60" ctrllimited="true" ctrlrange="-45 45"/>
            <position name="r1_eye_pitch_left_act" joint="r1_eye_pitch_left" gear="60" ctrllimited="true" ctrlrange="-30 30"/>
            <position name="r1_eye_yaw_right_act" joint="r1_eye_yaw_right" gear="60" ctrllimited="true" ctrlrange="-45 45"/>
            <position name="r1_eye_pitch_right_act" joint="r1_eye_pitch_right" gear="60" ctrllimited="true" ctrlrange="-30 30"/>

            <!-- Robot 2 Eye Actuators -->
            <position name="r2_eye_yaw_left_act" joint="r2_eye_yaw_left" gear="60" ctrllimited="true" ctrlrange="-45 45"/>
            <position name="r2_eye_pitch_left_act" joint="r2_eye_pitch_left" gear="60" ctrllimited="true" ctrlrange="-30 30"/>
            <position name="r2_eye_yaw_right_act" joint="r2_eye_yaw_right" gear="60" ctrllimited="true" ctrlrange="-45 45"/>
            <position name="r2_eye_pitch_right_act" joint="r2_eye_pitch_right" gear="60" ctrllimited="true" ctrlrange="-30 30"/>
      </actuator>

      <sensor>
        <!-- Robot 1 Sensors -->
        <jointvel name="r1_jvel_s1y" joint="r1_s1y"/> <jointvel name="r1_jvel_s1p" joint="r1_s1p"/> <jointvel name="r1_jvel_s1r" joint="r1_s1r"/> <jointvel name="r1_jvel_s1s" joint="r1_s1_slide"/>
        <jointvel name="r1_jvel_s2y" joint="r1_s2y"/> <jointvel name="r1_jvel_s2p" joint="r1_s2p"/> <jointvel name="r1_jvel_s2r" joint="r1_s2r"/> <jointvel name="r1_jvel_s2s" joint="r1_s2_slide"/>
        <jointvel name="r1_jvel_s3y" joint="r1_s3y"/> <jointvel name="r1_jvel_s3p" joint="r1_s3p"/> <jointvel name="r1_jvel_s3r" joint="r1_s3r"/> <jointvel name="r1_jvel_s3s" joint="r1_s3_slide"/>
        <jointvel name="r1_jvel_s4y" joint="r1_s4y"/> <jointvel name="r1_jvel_s4p" joint="r1_s4p"/> <jointvel name="r1_jvel_s4r" joint="r1_s4r"/> <jointvel name="r1_jvel_s4s" joint="r1_s4_slide"/>
        <jointvel name="r1_jvel_s5y" joint="r1_s5y"/> <jointvel name="r1_jvel_s5p" joint="r1_s5p"/> <jointvel name="r1_jvel_s5r" joint="r1_s5r"/> <jointvel name="r1_jvel_s5s" joint="r1_s5_slide"/>
        <jointvel name="r1_jvel_s6y" joint="r1_s6y"/> <jointvel name="r1_jvel_s6p" joint="r1_s6p"/> <jointvel name="r1_jvel_s6r" joint="r1_s6r"/> <jointvel name="r1_jvel_s6s" joint="r1_s6_slide"/>
        <jointvel name="r1_jvel_s7y" joint="r1_s7y"/> <jointvel name="r1_jvel_s7p" joint="r1_s7p"/> <jointvel name="r1_jvel_s7r" joint="r1_s7r"/> <jointvel name="r1_jvel_s7s" joint="r1_s7_slide"/>
        <jointvel name="r1_jvel_s8y" joint="r1_s8y"/> <jointvel name="r1_jvel_s8p" joint="r1_s8p"/> <jointvel name="r1_jvel_s8r" joint="r1_s8r"/> <jointvel name="r1_jvel_s8s" joint="r1_s8_slide"/>
        <jointvel name="r1_jvel_s9y" joint="r1_s9y"/> <jointvel name="r1_jvel_s9p" joint="r1_s9p"/> <jointvel name="r1_jvel_s9r" joint="r1_s9r"/> <jointvel name="r1_jvel_s9s" joint="r1_s9_slide"/>
        <jointvel name="r1_jvel_s10y" joint="r1_s10y"/> <jointvel name="r1_jvel_s10p" joint="r1_s10p"/> <jointvel name="r1_jvel_s10r" joint="r1_s10r"/> <jointvel name="r1_jvel_s10s" joint="r1_s10_slide"/>
        <jointvel name="r1_jvel_s11y" joint="r1_s11y"/> <jointvel name="r1_jvel_s11p" joint="r1_s11p"/> <jointvel name="r1_jvel_s11r" joint="r1_s11r"/> <jointvel name="r1_jvel_s11s" joint="r1_s11_slide"/>
        <jointvel name="r1_jvel_s12y" joint="r1_s12y"/> <jointvel name="r1_jvel_s12p" joint="r1_s12p"/> <jointvel name="r1_jvel_s12r" joint="r1_s12r"/> <jointvel name="r1_jvel_s12s" joint="r1_s12_slide"/>
        <jointvel name="r1_jvel_s13y" joint="r1_s13y"/> <jointvel name="r1_jvel_s13p" joint="r1_s13p"/> <jointvel name="r1_jvel_s13r" joint="r1_s13r"/> <jointvel name="r1_jvel_s13s" joint="r1_s13_slide"/>
        <actuatorfrc name="r1_afrc_s1y" actuator="r1m1y"/> <actuatorfrc name="r1_afrc_s1p" actuator="r1m1p"/> <actuatorfrc name="r1_afrc_s1r" actuator="r1m1r"/> <actuatorfrc name="r1_afrc_s1s" actuator="r1m1s"/>
        <actuatorfrc name="r1_afrc_s2y" actuator="r1m2y"/> <actuatorfrc name="r1_afrc_s2p" actuator="r1m2p"/> <actuatorfrc name="r1_afrc_s2r" actuator="r1m2r"/> <actuatorfrc name="r1_afrc_s2s" actuator="r1m2s"/>
        <actuatorfrc name="r1_afrc_s3y" actuator="r1m3y"/> <actuatorfrc name="r1_afrc_s3p" actuator="r1m3p"/> <actuatorfrc name="r1_afrc_s3r" actuator="r1m3r"/> <actuatorfrc name="r1_afrc_s3s" actuator="r1m3s"/>
        <actuatorfrc name="r1_afrc_s4y" actuator="r1m4y"/> <actuatorfrc name="r1_afrc_s4p" actuator="r1m4p"/> <actuatorfrc name="r1_afrc_s4r" actuator="r1m4r"/> <actuatorfrc name="r1_afrc_s4s" actuator="r1m4s"/>
        <actuatorfrc name="r1_afrc_s5y" actuator="r1m5y"/> <actuatorfrc name="r1_afrc_s5p" actuator="r1m5p"/> <actuatorfrc name="r1_afrc_s5r" actuator="r1m5r"/> <actuatorfrc name="r1_afrc_s5s" actuator="r1m5s"/>
        <actuatorfrc name="r1_afrc_s6y" actuator="r1m6y"/> <actuatorfrc name="r1_afrc_s6p" actuator="r1m6p"/> <actuatorfrc name="r1_afrc_s6r" actuator="r1m6r"/> <actuatorfrc name="r1_afrc_s6s" actuator="r1m6s"/>
        <actuatorfrc name="r1_afrc_s7y" actuator="r1m7y"/> <actuatorfrc name="r1_afrc_s7p" actuator="r1m7p"/> <actuatorfrc name="r1_afrc_s7r" actuator="r1m7r"/> <actuatorfrc name="r1_afrc_s7s" actuator="r1m7s"/>
        <actuatorfrc name="r1_afrc_s8y" actuator="r1m8y"/> <actuatorfrc name="r1_afrc_s8p" actuator="r1m8p"/> <actuatorfrc name="r1_afrc_s8r" actuator="r1m8r"/> <actuatorfrc name="r1_afrc_s8s" actuator="r1m8s"/>
        <actuatorfrc name="r1_afrc_s9y" actuator="r1m9y"/> <actuatorfrc name="r1_afrc_s9p" actuator="r1m9p"/> <actuatorfrc name="r1_afrc_s9r" actuator="r1m9r"/> <actuatorfrc name="r1_afrc_s9s" actuator="r1m9s"/>
        <actuatorfrc name="r1_afrc_s10y" actuator="r1m10y"/> <actuatorfrc name="r1_afrc_s10p" actuator="r1m10p"/> <actuatorfrc name="r1_afrc_s10r" actuator="r1m10r"/> <actuatorfrc name="r1_afrc_s10s" actuator="r1m10s"/>
        <actuatorfrc name="r1_afrc_s11y" actuator="r1m11y"/> <actuatorfrc name="r1_afrc_s11p" actuator="r1m11p"/> <actuatorfrc name="r1_afrc_s11r" actuator="r1m11r"/> <actuatorfrc name="r1_afrc_s11s" actuator="r1m11s"/>
        <actuatorfrc name="r1_afrc_s12y" actuator="r1m12y"/> <actuatorfrc name="r1_afrc_s12p" actuator="r1m12p"/> <actuatorfrc name="r1_afrc_s12r" actuator="r1m12r"/> <actuatorfrc name="r1_afrc_s12s" actuator="r1m12s"/>
        <actuatorfrc name="r1_afrc_s13y" actuator="r1m13y"/> <actuatorfrc name="r1_afrc_s13p" actuator="r1m13p"/> <actuatorfrc name="r1_afrc_s13r" actuator="r1m13r"/> <actuatorfrc name="r1_afrc_s13s" actuator="r1m13s"/>
        <gyro name="r1_gyro" site="r1_center"/>
        <accelerometer name="r1_accel" site="r1_center"/>
        <velocimeter name="r1_velo" site="r1_center"/>
        <magnetometer name="r1_magneto" site="r1_center"/>
        <touch name="r1_body_touch" site="r1_center"/>
        <touch name="r1_touch1" site="r1_s1_site"/> <touch name="r1_touch2" site="r1_s2_site"/>
        <touch name="r1_touch3" site="r1_s3_site"/> <touch name="r1_touch4" site="r1_s4_site"/>
        <touch name="r1_touch5" site="r1_s5_site"/> <touch name="r1_touch6" site="r1_s6_site"/>
        <touch name="r1_touch7" site="r1_s7_site"/> <touch name="r1_touch8" site="r1_s8_site"/>
        <touch name="r1_touch9" site="r1_s9_site"/> <touch name="r1_touch10" site="r1_s10_site"/>
        <touch name="r1_touch11" site="r1_s11_site"/> <touch name="r1_touch12" site="r1_s12_site"/>
        <touch name="r1_touch13" site="r1_s13_site"/>
        <rangefinder name="r1_ray_fwd" site="r1_ray_fwd_site" />
        <rangefinder name="r1_ray_fwd_l" site="r1_ray_fwd_l_site" />
        <rangefinder name="r1_ray_fwd_r" site="r1_ray_fwd_r_site" />
        <rangefinder name="r1_ray_45_l" site="r1_ray_45_l_site" />
        <rangefinder name="r1_ray_45_r" site="r1_ray_45_r_site" />
        <rangefinder name="r1_ray_90_l" site="r1_ray_90_l_site" />
        <rangefinder name="r1_ray_90_r" site="r1_ray_90_r_site" />
        <rangefinder name="r1_ray_back" site="r1_ray_back_site" />
        <rangefinder name="r1_ray_down" site="r1_ray_down_site" />
        <rangefinder name="r1_ray_up" site="r1_ray_up_site" />
        <force name="r1_force1" site="r1_s1_site"/> <force name="r1_force2" site="r1_s2_site"/>
        <force name="r1_force3" site="r1_s3_site"/> <force name="r1_force4" site="r1_s4_site"/>
        <force name="r1_force5" site="r1_s5_site"/> <force name="r1_force6" site="r1_s6_site"/>
        <force name="r1_force7" site="r1_s7_site"/> <force name="r1_force8" site="r1_s8_site"/>
        <force name="r1_force9" site="r1_s9_site"/> <force name="r1_force10" site="r1_s10_site"/>
        <force name="r1_force11" site="r1_s11_site"/> <force name="r1_force12" site="r1_s12_site"/>
        <force name="r1_force13" site="r1_s13_site"/>

        <!-- Robot 2 Sensors -->
        <jointvel name="r2_jvel_s1y" joint="r2_s1y"/> <jointvel name="r2_jvel_s1p" joint="r2_s1p"/> <jointvel name="r2_jvel_s1r" joint="r2_s1r"/> <jointvel name="r2_jvel_s1s" joint="r2_s1_slide"/>
        <jointvel name="r2_jvel_s2y" joint="r2_s2y"/> <jointvel name="r2_jvel_s2p" joint="r2_s2p"/> <jointvel name="r2_jvel_s2r" joint="r2_s2r"/> <jointvel name="r2_jvel_s2s" joint="r2_s2_slide"/>
        <jointvel name="r2_jvel_s3y" joint="r2_s3y"/> <jointvel name="r2_jvel_s3p" joint="r2_s3p"/> <jointvel name="r2_jvel_s3r" joint="r2_s3r"/> <jointvel name="r2_jvel_s3s" joint="r2_s3_slide"/>
        <jointvel name="r2_jvel_s4y" joint="r2_s4y"/> <jointvel name="r2_jvel_s4p" joint="r2_s4p"/> <jointvel name="r2_jvel_s4r" joint="r2_s4r"/> <jointvel name="r2_jvel_s4s" joint="r2_s4_slide"/>
        <jointvel name="r2_jvel_s5y" joint="r2_s5y"/> <jointvel name="r2_jvel_s5p" joint="r2_s5p"/> <jointvel name="r2_jvel_s5r" joint="r2_s5r"/> <jointvel name="r2_jvel_s5s" joint="r2_s5_slide"/>
        <jointvel name="r2_jvel_s6y" joint="r2_s6y"/> <jointvel name="r2_jvel_s6p" joint="r2_s6p"/> <jointvel name="r2_jvel_s6r" joint="r2_s6r"/> <jointvel name="r2_jvel_s6s" joint="r2_s6_slide"/>
        <jointvel name="r2_jvel_s7y" joint="r2_s7y"/> <jointvel name="r2_jvel_s7p" joint="r2_s7p"/> <jointvel name="r2_jvel_s7r" joint="r2_s7r"/> <jointvel name="r2_jvel_s7s" joint="r2_s7_slide"/>
        <jointvel name="r2_jvel_s8y" joint="r2_s8y"/> <jointvel name="r2_jvel_s8p" joint="r2_s8p"/> <jointvel name="r2_jvel_s8r" joint="r2_s8r"/> <jointvel name="r2_jvel_s8s" joint="r2_s8_slide"/>
        <jointvel name="r2_jvel_s9y" joint="r2_s9y"/> <jointvel name="r2_jvel_s9p" joint="r2_s9p"/> <jointvel name="r2_jvel_s9r" joint="r2_s9r"/> <jointvel name="r2_jvel_s9s" joint="r2_s9_slide"/>
        <jointvel name="r2_jvel_s10y" joint="r2_s10y"/> <jointvel name="r2_jvel_s10p" joint="r2_s10p"/> <jointvel name="r2_jvel_s10r" joint="r2_s10r"/> <jointvel name="r2_jvel_s10s" joint="r2_s10_slide"/>
        <jointvel name="r2_jvel_s11y" joint="r2_s11y"/> <jointvel name="r2_jvel_s11p" joint="r2_s11p"/> <jointvel name="r2_jvel_s11r" joint="r2_s11r"/> <jointvel name="r2_jvel_s11s" joint="r2_s11_slide"/>
        <jointvel name="r2_jvel_s12y" joint="r2_s12y"/> <jointvel name="r2_jvel_s12p" joint="r2_s12p"/> <jointvel name="r2_jvel_s12r" joint="r2_s12r"/> <jointvel name="r2_jvel_s12s" joint="r2_s12_slide"/>
        <jointvel name="r2_jvel_s13y" joint="r2_s13y"/> <jointvel name="r2_jvel_s13p" joint="r2_s13p"/> <jointvel name="r2_jvel_s13r" joint="r2_s13r"/> <jointvel name="r2_jvel_s13s" joint="r2_s13_slide"/>
        <actuatorfrc name="r2_afrc_s1y" actuator="r2m1y"/> <actuatorfrc name="r2_afrc_s1p" actuator="r2m1p"/> <actuatorfrc name="r2_afrc_s1r" actuator="r2m1r"/> <actuatorfrc name="r2_afrc_s1s" actuator="r2m1s"/>
        <actuatorfrc name="r2_afrc_s2y" actuator="r2m2y"/> <actuatorfrc name="r2_afrc_s2p" actuator="r2m2p"/> <actuatorfrc name="r2_afrc_s2r" actuator="r2m2r"/> <actuatorfrc name="r2_afrc_s2s" actuator="r2m2s"/>
        <actuatorfrc name="r2_afrc_s3y" actuator="r2m3y"/> <actuatorfrc name="r2_afrc_s3p" actuator="r2m3p"/> <actuatorfrc name="r2_afrc_s3r" actuator="r2m3r"/> <actuatorfrc name="r2_afrc_s3s" actuator="r2m3s"/>
        <actuatorfrc name="r2_afrc_s4y" actuator="r2m4y"/> <actuatorfrc name="r2_afrc_s4p" actuator="r2m4p"/> <actuatorfrc name="r2_afrc_s4r" actuator="r2m4r"/> <actuatorfrc name="r2_afrc_s4s" actuator="r2m4s"/>
        <actuatorfrc name="r2_afrc_s5y" actuator="r2m5y"/> <actuatorfrc name="r2_afrc_s5p" actuator="r2m5p"/> <actuatorfrc name="r2_afrc_s5r" actuator="r2m5r"/> <actuatorfrc name="r2_afrc_s5s" actuator="r2m5s"/>
        <actuatorfrc name="r2_afrc_s6y" actuator="r2m6y"/> <actuatorfrc name="r2_afrc_s6p" actuator="r2m6p"/> <actuatorfrc name="r2_afrc_s6r" actuator="r2m6r"/> <actuatorfrc name="r2_afrc_s6s" actuator="r2m6s"/>
        <actuatorfrc name="r2_afrc_s7y" actuator="r2m7y"/> <actuatorfrc name="r2_afrc_s7p" actuator="r2m7p"/> <actuatorfrc name="r2_afrc_s7r" actuator="r2m7r"/> <actuatorfrc name="r2_afrc_s7s" actuator="r2m7s"/>
        <actuatorfrc name="r2_afrc_s8y" actuator="r2m8y"/> <actuatorfrc name="r2_afrc_s8p" actuator="r2m8p"/> <actuatorfrc name="r2_afrc_s8r" actuator="r2m8r"/> <actuatorfrc name="r2_afrc_s8s" actuator="r2m8s"/>
        <actuatorfrc name="r2_afrc_s9y" actuator="r2m9y"/> <actuatorfrc name="r2_afrc_s9p" actuator="r2m9p"/> <actuatorfrc name="r2_afrc_s9r" actuator="r2m9r"/> <actuatorfrc name="r2_afrc_s9s" actuator="r2m9s"/>
        <actuatorfrc name="r2_afrc_s10y" actuator="r2m10y"/> <actuatorfrc name="r2_afrc_s10p" actuator="r2m10p"/> <actuatorfrc name="r2_afrc_s10r" actuator="r2m10r"/> <actuatorfrc name="r2_afrc_s10s" actuator="r2m10s"/>
        <actuatorfrc name="r2_afrc_s11y" actuator="r2m11y"/> <actuatorfrc name="r2_afrc_s11p" actuator="r2m11p"/> <actuatorfrc name="r2_afrc_s11r" actuator="r2m11r"/> <actuatorfrc name="r2_afrc_s11s" actuator="r2m11s"/>
        <actuatorfrc name="r2_afrc_s12y" actuator="r2m12y"/> <actuatorfrc name="r2_afrc_s12p" actuator="r2m12p"/> <actuatorfrc name="r2_afrc_s12r" actuator="r2m12r"/> <actuatorfrc name="r2_afrc_s12s" actuator="r2m12s"/>
        <actuatorfrc name="r2_afrc_s13y" actuator="r2m13y"/> <actuatorfrc name="r2_afrc_s13p" actuator="r2m13p"/> <actuatorfrc name="r2_afrc_s13r" actuator="r2m13r"/> <actuatorfrc name="r2_afrc_s13s" actuator="r2m13s"/>
        <gyro name="r2_gyro" site="r2_center"/>
        <accelerometer name="r2_accel" site="r2_center"/>
        <velocimeter name="r2_velo" site="r2_center"/>
        <magnetometer name="r2_magneto" site="r2_center"/>
        <touch name="r2_body_touch" site="r2_center"/>
        <touch name="r2_touch1" site="r2_s1_site"/> <touch name="r2_touch2" site="r2_s2_site"/>
        <touch name="r2_touch3" site="r2_s3_site"/> <touch name="r2_touch4" site="r2_s4_site"/>
        <touch name="r2_touch5" site="r2_s5_site"/> <touch name="r2_touch6" site="r2_s6_site"/>
        <touch name="r2_touch7" site="r2_s7_site"/> <touch name="r2_touch8" site="r2_s8_site"/>
        <touch name="r2_touch9" site="r2_s9_site"/> <touch name="r2_touch10" site="r2_s10_site"/>
        <touch name="r2_touch11" site="r2_s11_site"/> <touch name="r2_touch12" site="r2_s12_site"/>
        <touch name="r2_touch13" site="r2_s13_site"/>
        <rangefinder name="r2_ray_fwd" site="r2_ray_fwd_site" />
        <rangefinder name="r2_ray_fwd_l" site="r2_ray_fwd_l_site" />
        <rangefinder name="r2_ray_fwd_r" site="r2_ray_fwd_r_site" />
        <rangefinder name="r2_ray_45_l" site="r2_ray_45_l_site" />
        <rangefinder name="r2_ray_45_r" site="r2_ray_45_r_site" />
        <rangefinder name="r2_ray_90_l" site="r2_ray_90_l_site" />
        <rangefinder name="r2_ray_90_r" site="r2_ray_90_r_site" />
        <rangefinder name="r2_ray_back" site="r2_ray_back_site" />
        <rangefinder name="r2_ray_down" site="r2_ray_down_site" />
        <rangefinder name="r2_ray_up" site="r2_ray_up_site" />
        <force name="r2_force1" site="r2_s1_site"/> <force name="r2_force2" site="r2_s2_site"/>
        <force name="r2_force3" site="r2_s3_site"/> <force name="r2_force4" site="r2_s4_site"/>
        <force name="r2_force5" site="r2_s5_site"/> <force name="r2_force6" site="r2_s6_site"/>
        <force name="r2_force7" site="r2_s7_site"/> <force name="r2_force8" site="r2_s8_site"/>
        <force name="r2_force9" site="r2_s9_site"/> <force name="r2_force10" site="r2_s10_site"/>
        <force name="r2_force11" site="r2_s11_site"/> <force name="r2_force12" site="r2_s12_site"/>
        <force name="r2_force13" site="r2_s13_site"/>
      </sensor>
</mujoco>

--------------------------

--- FILE: src/main_train.cpp ---
// STRICT REQUIREMENT: Jolt.h must be included first
#include <Jolt/Jolt.h>
#include <Jolt/RegisterTypes.h>
#include <Jolt/Core/Factory.h>

#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include <imgui/imgui.h>
#include <imgui/imgui_impl_glfw.h>
#include <imgui/imgui_impl_opengl3.h>

#include <iostream>
#include <chrono>
#include <vector>
#include <random>
#include <filesystem>
#include <thread>
#include <atomic>
#include <algorithm>
#include <cstring>

#include "VectorizedEnv.h"
#include "NeuralNetwork.h"
#include "TD3Trainer.h"
#include "Renderer.h"
#include "LockFreeQueue.h"

// Include nlohmann JSON library for telemetry serialization
#include <nlohmann/json.hpp>

namespace fs = std::filesystem;

struct TelemetryData
{
    alignas(32) float envStates[128 * 240 * 2];  // 128 envs * 240 obs dim * 2 robots
    alignas(32) float globalReward[128 * 2];      // 128 envs * 2 rewards
    alignas(32) float jointStress[128 * 13 * 2];  // 128 envs * 13 satellites * 2 robots
    int numEnvs = 128;
    int stepCount = 0;
};

using TelemetryQueue = LockFreeSPSCQueue<TelemetryData, 8>;

// Global telemetry queue for communication between training and telemetry threads
TelemetryQueue gTelemetryQueue;
std::atomic<bool> gTelemetryRunning(false);

void TelemetryThreadFunction()
{
    gTelemetryRunning = true;
    
    while (gTelemetryRunning)
    {
        TelemetryData data;
        if (gTelemetryQueue.Pop(data))
        {
            // Convert telemetry data to JSON
            nlohmann::json jsonData;
            jsonData["stepCount"] = data.stepCount;
            jsonData["numEnvs"] = data.numEnvs;
            
            // Add environment states (first 10 values for brevity)
            nlohmann::json envStatesJson = nlohmann::json::array();
            for (int i = 0; i < std::min(10, data.numEnvs * 240 * 2); ++i)
            {
                envStatesJson.push_back(data.envStates[i]);
            }
            jsonData["envStates"] = envStatesJson;
            
            // Add rewards (first 10 values)
            nlohmann::json rewardsJson = nlohmann::json::array();
            for (int i = 0; i < std::min(10, data.numEnvs * 2); ++i)
            {
                rewardsJson.push_back(data.globalReward[i]);
            }
            jsonData["rewards"] = rewardsJson;
            
            // Add joint stress (first 10 values)
            nlohmann::json jointStressJson = nlohmann::json::array();
            for (int i = 0; i < std::min(10, data.numEnvs * 13 * 2); ++i)
            {
                jointStressJson.push_back(data.jointStress[i]);
            }
            jsonData["jointStress"] = jointStressJson;
            
            // In a real implementation, we would send this JSON data over a WebSocket
            // For now, we'll just print a message to indicate the data is ready
            // std::cout << "[Telemetry] Data prepared for step " << data.stepCount << std::endl;
        }
        
        // Small delay to control telemetry frequency
        std::this_thread::sleep_for(std::chrono::milliseconds(16)); // ~60 Hz
    }
}

struct TrainingConfig {
    int numParallelEnvs = 2;
    int checkpointInterval = 50000;
    int maxSteps = 10000000;
    std::string checkpointDir = "checkpoints";
    std::string loadCheckpoint = "";
};

void EnsureDir(const std::string& path) {
    if (!fs::exists(path)) {
        fs::create_directories(path);
    }
}

int main(int argc, char* argv[]) {
    TrainingConfig config;
    
    // Start telemetry thread
    std::thread telemetryThread(TelemetryThreadFunction);
    
    // 1. Initialize Window and Context
    if (!glfwInit()) return -1;
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    GLFWwindow* window = glfwCreateWindow(1280, 720, "JOLTrl Hybrid Overseer", nullptr, nullptr);
    if (!window) {
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    
    // UNLOCK FRAMERATE: Do not let Vsync block our training matrix
    glfwSwapInterval(0); 

    if (glewInit() != GLEW_OK) return -1;

    // --- THE "UNGODLY ABOMINATION" FIX ---
    // Enforces 3D depth, but we MUST leave culling off because 
    // the sphere meshes are wound clockwise!
    glEnable(GL_DEPTH_TEST);
    // glDisable(GL_CULL_FACE); // Make sure this is completely gone or disabled!
    // -------------------------------------

    // 2. Initialize ImGui
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGui_ImplGlfw_InitForOpenGL(window, true);
    ImGui_ImplOpenGL3_Init("#version 330");

    EnsureDir(config.checkpointDir);
    EnsureDir("saved_models");
    
    // 3. Initialize Training Environment
    VectorizedEnv vecEnv(config.numParallelEnvs);
    vecEnv.Init();
    Renderer renderer(1280, 720);
    
    int stateDim = vecEnv.GetObservationDim();
    int actionDim = vecEnv.GetActionDim();
    int totalActionDim = actionDim * 2 * config.numParallelEnvs;
    
    TD3Config td3cfg;
    td3cfg.hiddenDim = 256;
    td3cfg.batchSize = 256;
    td3cfg.startSteps = 10000;
    
    TD3Trainer trainer(stateDim, actionDim, td3cfg);
    ReplayBuffer buffer(td3cfg.bufferSize, stateDim, actionDim);
    
    AlignedVector32<float> actions(totalActionDim, 0.0f);
    std::mt19937 rng(42);
    std::normal_distribution<float> noiseDist(0.0f, 1.0f);
    
     auto last_time = std::chrono::high_resolution_clock::now();
     int step_counter = 0;
     double current_sps = 0.0;
     int selectedEnvIdx = 0;
     bool renderEnabled = true;
     Camera camera;

     std::cout << "[JOLTrl] Visualizer Matrix Engaged. Suppressing per-frame debug spam." << std::endl;

     while (!glfwWindowShouldClose(window)) {
         
         // 1. Generate kinetic jitter actions
         AlignedVector32<float> actions(config.numParallelEnvs * 2 * 56);
         for (float& a : actions) {
             // Apply massive random forces to make them jump/move visibly
             a = ((float)rand() / RAND_MAX) * 2.0f - 1.0f;
         }

         // 2. Step the physics matrix silently
         vecEnv.Step(actions);
         vecEnv.ResetDoneEnvs();

         // 3. SPS Calculation & Telemetry (1-second sliding window)
         step_counter += config.numParallelEnvs;
         auto now = std::chrono::high_resolution_clock::now();
         std::chrono::duration<double> elapsed = now - last_time;
         
         // Only update UI and Terminal once per second to prevent I/O choking
         if (elapsed.count() >= 1.0) {
             current_sps = step_counter / elapsed.count();
             
             // THE RADAR PING: Let's see if Robot 0 is actually moving
             const auto& obs = vecEnv.GetObservations();
             if (obs.size() >= 3) {
                 // Assuming obs[1] is the Y-axis (Altitude) of the chassis
                 std::cout << "[TELEMETRY] SPS: " << (int)current_sps 
                           << " | Env[0] Robot[0] Altitude (Y): " << obs[1] 
                           << std::endl;
             } else {
                 std::cout << "[TELEMETRY] SPS: " << (int)current_sps << std::endl;
             }
             
             step_counter = 0;
             last_time = now;
         }

         // 4. Render Frame
         // (If the screen is still grey, your camera origin is trapped inside the floor mesh!)
         double currentTime = glfwGetTime();
         static double lastRenderTime = currentTime;
         if (currentTime - lastRenderTime >= (1.0 / 60.0)) {
             lastRenderTime = currentTime;
             glfwPollEvents();

               // Fixed camera position (no rotation)
               glm::vec3 camPos(10.0f, 8.0f, 10.0f);

             // Draw exactly 1 environment via the Dimensional Filter
             if (renderEnabled) {
                 renderer.Draw(vecEnv.GetGlobalPhysics(), camPos, selectedEnvIdx);
             } else {
                 glClearColor(0.02f, 0.02f, 0.05f, 1.0f);
                 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
             }

             // Draw ImGui Overlay
             ImGui_ImplOpenGL3_NewFrame();
             ImGui_ImplGlfw_NewFrame();
             ImGui::NewFrame();

             ImGui::SetNextWindowPos(ImVec2(10, 10), ImGuiCond_FirstUseEver);
             ImGui::SetNextWindowSize(ImVec2(300, 180), ImGuiCond_FirstUseEver);
             ImGui::Begin("JOLTrl Hybrid Overseer");
             ImGui::Text("Silicon: Intel i5-10500");
             ImGui::Text("Graphics: Intel HD 630");
             ImGui::Separator();
             ImGui::Text("Parallel Envs: %d", config.numParallelEnvs);
             ImGui::Text("Total Steps: %d", step_counter);
             ImGui::Text("Steps Per Second: %.0f", current_sps);
             ImGui::Separator();
             ImGui::Checkbox("Enable Rendering", &renderEnabled);
             ImGui::SliderInt("Watch Env", &selectedEnvIdx, 0, config.numParallelEnvs - 1);
             ImGui::End();

             // Camera controls window
             ImGui::SetNextWindowPos(ImVec2(10, 250), ImGuiCond_FirstUseEver);
             ImGui::Begin("Camera", nullptr, ImGuiWindowFlags_AlwaysAutoResize);
             ImGui::SliderFloat("Distance", &camera.distance, 5.0f, 50.0f);
             ImGui::SliderFloat("Pitch", &camera.pitch, -1.5f, 1.5f);
             ImGui::SliderFloat("Yaw", &camera.yaw, -3.14f, 3.14f);
             ImGui::End();

             ImGui::Render();
             ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
             glfwSwapBuffers(window);
         }
     }
    
    trainer.Save("saved_models/model_final.bin");
    
    // Stop telemetry thread
    gTelemetryRunning = false;
    if (telemetryThread.joinable()) {
        telemetryThread.join();
    }
    
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();
    glfwTerminate();
    
    return 0;
}
--------------------------

--- FILE: src/PhysicsCore.h ---
#pragma once

// STRICT REQUIREMENT: Jolt.h must be included first
#include <Jolt/Jolt.h>
#include <Jolt/Physics/PhysicsSystem.h>
#include <Jolt/Physics/Collision/BroadPhase/BroadPhaseLayer.h>
#include <Jolt/Physics/Collision/ObjectLayer.h>
#include <Jolt/Core/JobSystemThreadPool.h>

#include <vector>

namespace Layers
{
    // Layer 0 is the universal static layer (e.g., the floor)
    static constexpr JPH::ObjectLayer STATIC = 0;

    // Every parallel environment gets its own exclusive layer starting from 1
    // e.g., Env 0 -> Layer 1, Env 1 -> Layer 2.
    static constexpr JPH::ObjectLayer MOVING_BASE = 1;
}

namespace BroadPhaseLayers
{
    static constexpr JPH::BroadPhaseLayer STATIC(0);
    static constexpr JPH::BroadPhaseLayer DYNAMIC(1);
    static constexpr uint NUM_LAYERS = 2;
}

// Maps the thousands of ObjectLayers down to just 2 BroadPhase trees (Static vs Dynamic)
class BPLayerInterfaceImpl final : public JPH::BroadPhaseLayerInterface
{
public:
    BPLayerInterfaceImpl(uint32_t numEnvs) : mNumEnvs(numEnvs)
    {
    }

    virtual uint GetNumBroadPhaseLayers() const override { return BroadPhaseLayers::NUM_LAYERS; }

    virtual JPH::BroadPhaseLayer GetBroadPhaseLayer(JPH::ObjectLayer inLayer) const override
    {
        if (inLayer == Layers::STATIC) return BroadPhaseLayers::STATIC;
        return BroadPhaseLayers::DYNAMIC;
    }

#if defined(JPH_EXTERNAL_PROFILE) || defined(JPH_PROFILE_ENABLED)
    virtual const char* GetBroadPhaseLayerName(JPH::BroadPhaseLayer inLayer) const override
    {
        switch ((JPH::BroadPhaseLayer::Type)inLayer)
        {
        case (JPH::BroadPhaseLayer::Type)BroadPhaseLayers::STATIC: return "Static";
        case (JPH::BroadPhaseLayer::Type)BroadPhaseLayers::DYNAMIC: return "Dynamic";
        default: return "Invalid";
        }
    }
#endif // JPH_EXTERNAL_PROFILE || JPH_PROFILE_ENABLED

private:
    uint32_t mNumEnvs;
};

class ObjectVsBroadPhaseLayerFilterImpl final : public JPH::ObjectVsBroadPhaseLayerFilter
{
public:
    virtual bool ShouldCollide(JPH::ObjectLayer inLayer1, JPH::BroadPhaseLayer inLayer2) const override
    {
        if (inLayer1 == Layers::STATIC) return inLayer2 == BroadPhaseLayers::DYNAMIC;
        return true; // Dynamic objects can collide with both Static and Dynamic broadphases
    }
};

// DIMENSIONAL GHOSTING CORE LOGIC
class ObjectLayerPairFilterImpl final : public JPH::ObjectLayerPairFilter
{
public:
    virtual bool ShouldCollide(JPH::ObjectLayer inObject1, JPH::ObjectLayer inObject2) const override
    {
        // 1. Static objects don't collide with other static objects
        if (inObject1 == Layers::STATIC && inObject2 == Layers::STATIC) return false;
 // 2. Everything collides with the static environment (Floor)
        if (inObject1 == Layers::STATIC || inObject2 == Layers::STATIC) return true;

        // 3. Two dynamic objects ONLY collide if they belong to the exact same environment
        return inObject1 == inObject2;
    }
};

class PhysicsCore
{
public:
    PhysicsCore() = default;
    ~PhysicsCore();

    PhysicsCore(const PhysicsCore&) = delete;
    PhysicsCore& operator=(const PhysicsCore&) = delete;
    PhysicsCore(PhysicsCore&&) = delete;
    PhysicsCore& operator=(PhysicsCore&&) = delete;

    // We now pass the number of parallel environments to scale the memory pools
    bool Init(uint32_t numParallelEnvs);
    void Step(float deltaTime);
    void Shutdown();

    JPH::PhysicsSystem& GetPhysicsSystem() { return *mPhysicsSystem; }
    const JPH::PhysicsSystem& GetPhysicsSystem() const { return *mPhysicsSystem; }

private:
    JPH::TempAllocatorImpl* mTempAllocator = nullptr;
    JPH::JobSystemThreadPool* mJobSystem = nullptr;
    BPLayerInterfaceImpl* mBroadPhaseLayerInterface = nullptr;
    ObjectVsBroadPhaseLayerFilterImpl* mObjectVsBroadPhaseLayerFilter = nullptr;
    ObjectLayerPairFilterImpl* mObjectLayerPairFilter = nullptr;
    JPH::PhysicsSystem* mPhysicsSystem = nullptr;

    bool mInitialized = false;
    uint32_t mNumEnvs = 1;
};
--------------------------

--- FILE: src/PhysicsCore.cpp ---
// STRICT REQUIREMENT: Jolt.h must be included first
#include <Jolt/Jolt.h>
#include <Jolt/RegisterTypes.h>
#include <Jolt/Core/Factory.h>
#include "PhysicsCore.h"

#include <cstdint>
#include <iostream>
#include <mutex>
#include <pthread.h>
#include <sched.h>
#include <Jolt/Physics/Collision/Shape/BoxShape.h>
#include <Jolt/Physics/Body/BodyCreationSettings.h>


PhysicsCore::~PhysicsCore()
{
    Shutdown();
}

bool PhysicsCore::Init(uint32_t numParallelEnvs)
{
    if (mInitialized) return true;
    mNumEnvs = numParallelEnvs;

    JPH::RegisterDefaultAllocator();

    uint32_t tempAllocSize = 256 * 1024 * 1024;
    mTempAllocator = new JPH::TempAllocatorImpl(tempAllocSize);

    // Thread Pinning Strategy: 
    // Target: 6 cores / 12 threads.
    // Core 0 (Threads 0 & 6) is left free for the Pop!_OS scheduler and the neural network.
    // We strictly spawn exactly 10 worker threads and pin them to Cores 1-5 (Threads 1-5, 7-11).
    uint32_t joltWorkerThreads = 10;

    mJobSystem = new JPH::JobSystemThreadPool(
        JPH::cMaxPhysicsJobs,
        JPH::cMaxPhysicsBarriers,
        joltWorkerThreads
    );

    // Pinning the Jolt thread pool to hardware cores
    std::cout << "[JOLTrl] Pinned " << joltWorkerThreads << " Jolt worker threads to bare metal." << std::endl;

    // Thread-safe Jolt initialization using static local initialization (C++11 guarantees)
    static std::once_flag joltInitFlag;
    std::call_once(joltInitFlag, []() {
        JPH::Factory::sInstance = new JPH::Factory();
        JPH::RegisterTypes();
    });

    mBroadPhaseLayerInterface = new BPLayerInterfaceImpl(mNumEnvs);
    mObjectVsBroadPhaseLayerFilter = new ObjectVsBroadPhaseLayerFilterImpl();
    mObjectLayerPairFilter = new ObjectLayerPairFilterImpl();

    // Scale physics system capacities for Dimensional Ghosting
    const uint32_t bodiesPerEnv = 60; // 2 robots * 27 bodies + safety margin
    const uint32_t maxBodies = std::max<uint32_t>(1024, mNumEnvs * bodiesPerEnv + 256);
    const uint32_t numBodyMutexes = std::max<uint32_t>(1, mNumEnvs / 4); // Mutex per ~4 envs
    const uint32_t maxBodyPairs = std::min<uint32_t>(65536, maxBodies * 4); // Cap at 64K
    const uint32_t maxContactConstraints = maxBodyPairs;

    mPhysicsSystem = new JPH::PhysicsSystem();
    mPhysicsSystem->Init(
        maxBodies,
        numBodyMutexes,
        maxBodyPairs,
        maxContactConstraints,
        *mBroadPhaseLayerInterface,
        *mObjectVsBroadPhaseLayerFilter,
        *mObjectLayerPairFilter
    );

    mPhysicsSystem->SetGravity(JPH::Vec3(0.0f, -9.81f, 0.0f));

    JPH::PhysicsSettings physicsSettings;

    // RL Optimization: Lower iterations for max SPS, agents will adapt to the slop
    physicsSettings.mNumVelocitySteps = 6;
    physicsSettings.mNumPositionSteps = 1;
    physicsSettings.mBaumgarte = 0.2f;

    mPhysicsSystem->SetPhysicsSettings(physicsSettings);

    mInitialized = true;
    std::cout << "[JOLTrl] PhysicsCore initialized globally for " << mNumEnvs << " overlapping environments." <<
        std::endl;
    return true;
}

void PhysicsCore::Shutdown()
{
    if (!mInitialized) return;

    delete mPhysicsSystem;
    mPhysicsSystem = nullptr;

    delete mObjectLayerPairFilter;
    mObjectLayerPairFilter = nullptr;

    delete mObjectVsBroadPhaseLayerFilter;
    mObjectVsBroadPhaseLayerFilter = nullptr;

    delete mBroadPhaseLayerInterface;
    mBroadPhaseLayerInterface = nullptr;

    // Only delete the factory if we created it and it's not null
    if (JPH::Factory::sInstance != nullptr)
    {
        JPH::Factory* factory = JPH::Factory::sInstance;
        JPH::Factory::sInstance = nullptr;
        delete factory;
    }

    delete mJobSystem;
    mJobSystem = nullptr;

    delete mTempAllocator;
    mTempAllocator = nullptr;

    mInitialized = false;
}

void PhysicsCore::Step(float deltaTime)
{
    if (!mInitialized) return;

    // Keep collision steps strictly to 1 to blast through the SPS ceiling
    constexpr int cCollisionSteps = 1;

    mPhysicsSystem->Update(deltaTime, cCollisionSteps, mTempAllocator, mJobSystem);
}

--------------------------
